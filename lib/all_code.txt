
--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\main.dart ---

// lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/core/router/app_router.dart';
import 'package:load_balance/data/datasources/remote_datasource_impl.dart';
import 'package:load_balance/data/repositories/device_repository_impl.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';
import 'package:load_balance/domain/usecases/check_credentials.dart';
import 'package:load_balance/domain/usecases/get_interfaces.dart';
import 'package:load_balance/domain/usecases/get_routing_table.dart';
import 'package:load_balance/domain/usecases/ping_gateway.dart';
import 'package:load_balance/presentation/bloc/connection/connection_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_bloc.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return RepositoryProvider<DeviceRepository>(
      create: (context) => DeviceRepositoryImpl(
        remoteDataSource: RemoteDataSourceImpl(),
      ),
      child: MultiBlocProvider(
        providers: [
          BlocProvider(
            create: (context) => ConnectionBloc(
              checkCredentials: CheckCredentials(context.read<DeviceRepository>()),
            ),
          ),
          BlocProvider(
            create: (context) {
              final repository = context.read<DeviceRepository>();
              return LoadBalancingBloc(
                getInterfaces: GetInterfaces(repository),
                getRoutingTable: GetRoutingTable(repository),
                // The PingGateway use case now correctly depends on the repository
                pingGateway: PingGateway(repository),
              );
            },
          ),
        ],
        child: MaterialApp.router(
          title: 'Cisco Load Balancer',
          theme: ThemeData(
            primarySwatch: Colors.blue,
            useMaterial3: true,
            brightness: Brightness.dark,
            cardTheme: CardThemeData(elevation: 2, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0))),
            inputDecorationTheme: const InputDecorationTheme(border: OutlineInputBorder(borderRadius: BorderRadius.all(Radius.circular(12.0)))),
            segmentedButtonTheme: SegmentedButtonThemeData(
              style: ButtonStyle(shape: WidgetStateProperty.all(RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)))),
            ),
          ),
          routerConfig: AppRouter.router,
        ),
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\test.dart ---

// import 'package:dart_ping/dart_ping.dart';

// void main() async {
//   // Create ping object with desired args
//   final ping = Ping('google.com', count: 5);

//   // [Optional]
//   // Preview command that will be run (helpful for debugging)
//   print('Running command: ${ping.command}');

//   // Begin ping process and listen for output
//   ping.stream.listen((event) {
//     print(event);
//   });
// }

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\core\error\failure.dart ---

// core/error/failure.dart
import 'package:equatable/equatable.dart';

abstract class Failure extends Equatable {
  final String message;
  const Failure(this.message);

  @override
  List<Object> get props => [message];
}

// Failure specific to server/connection errors
class ServerFailure extends Failure {
  const ServerFailure(super.message);
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\core\router\app_router.dart ---

// core/router/app_router.dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/presentation/screens/load_balancing/load_balancing_screen.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';

class AppRouter {
  static final GoRouter router = GoRouter(
    initialLocation: '/',
    routes: [
      GoRoute(
        path: '/',
        name: 'connection',
        builder: (BuildContext context, GoRouterState state) {
          return const ConnectionScreen();
        },
      ),
      GoRoute(
        path: '/config',
        name: 'config',
        builder: (BuildContext context, GoRouterState state) {
          // Receive the credentials object from the previous screen
          final credentials = state.extra as DeviceCredentials;
          return LoadBalancingScreen(credentials: credentials);
        },
      ),
    ],
  );
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\core\usecase\usecase.dart ---


--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\datasources\remote_datasource.dart ---

// lib/data/datasources/remote_datasource.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';

abstract class RemoteDataSource {
  Future<void> checkRestApiCredentials(DeviceCredentials credentials);
  Future<List<RouterInterface>> fetchInterfaces(DeviceCredentials credentials);
  Future<String> getRoutingTable(DeviceCredentials credentials);
  // Add the pingGateway method back to the interface
  Future<String> pingGateway(DeviceCredentials credentials, String ipAddress);
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\datasources\remote_datasource_impl.dart ---

// lib/data/datasources/remote_datasource_impl.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:dartssh2/dartssh2.dart';
import 'package:dio/dio.dart';
import 'package:dio/io.dart';
import 'package:flutter/foundation.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';
import 'package:ctelnet/ctelnet.dart';
import 'remote_datasource.dart';

class RemoteDataSourceImpl implements RemoteDataSource {
  static const _commandTimeout = Duration(seconds: 20);

  // =======================================================================
  // SSH Implementation (Stable)
  // =======================================================================

  Future<SSHClient> _createSshClient(DeviceCredentials credentials) async {
    try {
      final socket = await SSHSocket.connect(credentials.ip, 22,
          timeout: const Duration(seconds: 10));
      return SSHClient(
        socket,
        username: credentials.username,
        onPasswordRequest: () => credentials.password,
      );
    } on TimeoutException {
      throw const ServerFailure('Connection timed out.');
    } on SocketException {
      throw const ServerFailure('Could not connect to host.');
    } catch (e) {
      if (e.toString().toLowerCase().contains('auth')) {
        throw const ServerFailure('Authentication failed.');
      }
      throw ServerFailure('SSH Error: ${e.toString()}');
    }
  }

  // =======================================================================
  // Telnet Implementation
  // =======================================================================

  /// Executes standard, non-interactive commands over Telnet.
  Future<String> _executeTelnetCommands(
      DeviceCredentials credentials, List<String> commands) async {
    final completer = Completer<String>();
    final outputBuffer = StringBuffer();
    CTelnetClient? client;
    StreamSubscription<Message>? subscription;

    var state = 'login';
    int commandIndex = 0;
    final allCommands = ['terminal length 0', ...commands];

    client = CTelnetClient(
      host: credentials.ip,
      port: 23,
      timeout: const Duration(seconds: 15),
      onConnect: () => debugPrint('[TELNET] Connected.'),
      onDisconnect: () {
        debugPrint('[TELNET] Disconnected.');
        if (!completer.isCompleted) {
          completer.complete(outputBuffer.toString());
        }
        subscription?.cancel();
      },
      onError: (error) {
        if (!completer.isCompleted) {
          completer.completeError(ServerFailure("Telnet Error: $error"));
        }
        subscription?.cancel();
      },
    );

    try {
      subscription = (await client.connect())?.listen((data) {
        final receivedText = data.text.trim();
        outputBuffer.write(data.text);
        debugPrint("<< TELNET RECV: ${receivedText.replaceAll('\r\n', ' ')}");

        void executeNextCommand() {
          if (commandIndex < allCommands.length) {
            final cmd = allCommands[commandIndex];
            debugPrint(">> TELNET SEND: $cmd");
            client?.send('$cmd\n');
            commandIndex++;
          } else {
            if (!completer.isCompleted) {
              client?.disconnect();
            }
          }
        }

        switch (state) {
          case 'login':
            if (receivedText.toLowerCase().contains('username')) {
              client?.send('${credentials.username}\n');
            } else if (receivedText.toLowerCase().contains('password')) {
              client?.send('${credentials.password}\n');
            } else if (receivedText.endsWith('>')) {
              state = 'enable';
              client?.send('enable\n');
            } else if (receivedText.endsWith('#')) {
              state = 'executing';
              outputBuffer.clear();
              executeNextCommand();
            }
            break;
          case 'enable':
            if (receivedText.toLowerCase().contains('password')) {
              client?.send('${credentials.enablePassword ?? ''}\n');
            } else if (receivedText.endsWith('#')) {
              state = 'executing';
              outputBuffer.clear();
              executeNextCommand();
            }
            break;
          case 'executing':
            if (receivedText.endsWith('#')) {
              if (commandIndex < allCommands.length) {
                executeNextCommand();
              } else {
                if (!completer.isCompleted) {
                  client?.disconnect();
                }
              }
            }
            break;
        }
      });
    } catch (e) {
      if (!completer.isCompleted) {
        completer.completeError(ServerFailure("Telnet Connection Failed: $e"));
      }
    }

    return completer.future.timeout(_commandTimeout, onTimeout: () {
      client?.disconnect();
      throw const ServerFailure("Telnet operation timed out.");
    });
  }

  /// A specialized method to handle the interactive nature of the ping command over Telnet.
  Future<String> _executeTelnetPing(
      DeviceCredentials credentials, String ipAddress) async {
    final completer = Completer<String>();
    CTelnetClient? client;
    StreamSubscription<Message>? subscription;
    var state = 'login';

    client = CTelnetClient(
      host: credentials.ip,
      port: 23,
      timeout: const Duration(seconds: 15),
      onConnect: () => debugPrint('[PING] Connected.'),
      onDisconnect: () {
        debugPrint('[PING] Disconnected.');
        if (!completer.isCompleted) {
          // If we disconnect before getting a clear result, it's a failure.
          completer.complete('Ping failed. Check IP or connectivity.');
        }
        subscription?.cancel();
      },
      onError: (error) => !completer.isCompleted ? completer.completeError(error) : null,
    );

    try {
      subscription = (await client.connect())?.listen((data) {
        final receivedText = data.text;
        debugPrint("<< PING RECV: ${receivedText.replaceAll('\r\n', ' ')}");

        // Look for immediate success or failure indicators
        if (receivedText.contains('!!!')) {
          if (!completer.isCompleted) {
            completer.complete('Success! Gateway is reachable.');
            client?.disconnect();
          }
        } else if (receivedText.contains('...')) {
           if (!completer.isCompleted) {
            completer.complete('Timeout. Gateway is not reachable.');
            client?.disconnect();
          }
        }

        // Handle login process
        final trimmedText = receivedText.trim();
        if (state == 'login') {
          if (trimmedText.toLowerCase().contains('username')) {
            client?.send('${credentials.username}\n');
          } else if (trimmedText.toLowerCase().contains('password')) {
            client?.send('${credentials.password}\n');
          } else if (trimmedText.endsWith('>')) {
            state = 'enable';
            client?.send('enable\n');
          } else if (trimmedText.endsWith('#')) {
            state = 'executing';
            client?.send('ping $ipAddress repeat 2\n');
          }
        } else if (state == 'enable') {
           if (trimmedText.toLowerCase().contains('password')) {
            client?.send('${credentials.enablePassword ?? ''}\n');
          } else if (trimmedText.endsWith('#')) {
            state = 'executing';
            client?.send('ping $ipAddress repeat 2\n');
          }
        }
      });
    } catch (e) {
       if (!completer.isCompleted) {
          completer.completeError(ServerFailure("Ping Connection Failed: $e"));
       }
    }

    return completer.future.timeout(_commandTimeout, onTimeout: () {
      client?.disconnect();
      // If we time out without a clear success/fail, report a generic timeout.
      return 'Timeout. Gateway is not reachable.';
    });
  }

  // =======================================================================
  // Public API Methods (Now using the correct Telnet helpers)
  // =======================================================================

  @override
  Future<List<RouterInterface>> fetchInterfaces(
      DeviceCredentials credentials) async {
    String result;
    if (credentials.type == ConnectionType.ssh) {
      SSHClient? client;
      try {
        client = await _createSshClient(credentials);
        final rawResult =
            await client.run('show ip interface brief').timeout(_commandTimeout);
        result = utf8.decode(rawResult);
      } finally {
        client?.close();
      }
    } else {
      result =
          await _executeTelnetCommands(credentials, ['show ip interface brief']);
    }

    final lines = result.split('\n');
    final interfaces = <RouterInterface>[];
    final regex = RegExp(
        r'^(\S+)\s+([\d\.]+)\s+\w+\s+\w+\s+(up|down|administratively down)');

    for (final line in lines) {
      final match = regex.firstMatch(line);
      if (match != null) {
        interfaces.add(RouterInterface(
          name: match.group(1)!,
          ipAddress: match.group(2)!,
          status: match.group(3)!,
        ));
      }
    }
    return interfaces;
  }

  @override
  Future<String> getRoutingTable(DeviceCredentials credentials) async {
    String rawResult;

    if (credentials.type == ConnectionType.ssh) {
      SSHClient? client;
      try {
        client = await _createSshClient(credentials);
        final sshRawResult = await client
            .run('terminal length 0\nshow ip route')
            .timeout(_commandTimeout);
        rawResult = utf8.decode(sshRawResult);
      } finally {
        client?.close();
      }
    } else {
      rawResult = await _executeTelnetCommands(credentials, ['show ip route']);
    }

    final startOfOutput = rawResult.indexOf('show ip route');
    final endOfOutput = rawResult.lastIndexOf(RegExp(r'\S+[>#]'));
    if (startOfOutput != -1 && endOfOutput > startOfOutput) {
      return rawResult
          .substring(startOfOutput + 'show ip route'.length, endOfOutput)
          .trim();
    }
    return rawResult;
  }

  @override
  Future<String> pingGateway(
      DeviceCredentials credentials, String ipAddress) async {
    if (credentials.type == ConnectionType.ssh) {
      SSHClient? client;
      try {
        client = await _createSshClient(credentials);
        final rawSshResult =
            await client.run('ping $ipAddress repeat 2').timeout(_commandTimeout);
        final result = utf8.decode(rawSshResult);
        if (result.contains('!!!')) return 'Success! Gateway is reachable.';
        if (result.contains('...')) return 'Timeout. Gateway is not reachable.';
        return 'Ping failed. Check IP or connectivity.';
      } finally {
        client?.close();
      }
    } else {
      // Use the new, specialized ping method for Telnet
      return await _executeTelnetPing(credentials, ipAddress);
    }
  }

  @override
  Future<void> checkRestApiCredentials(DeviceCredentials credentials) async {
    final dio = Dio();
    final String basicAuth =
        'Basic ${base64Encode(utf8.encode('${credentials.username}:${credentials.password}'))}';
    (dio.httpClientAdapter as IOHttpClientAdapter).createHttpClient = () {
      final client = HttpClient();
      client.badCertificateCallback =
          (X509Certificate cert, String host, int port) => true;
      return client;
    };
    try {
      await dio.get(
        'https://${credentials.ip}/restconf/data/Cisco-IOS-XE-native:native',
        options: Options(
          headers: {
            'Authorization': basicAuth,
            'Accept': 'application/yang-data+json'
          },
          receiveTimeout: const Duration(seconds: 10),
        ),
      );
    } on DioException catch (e) {
      if (e.response?.statusCode == 401) {
        throw const ServerFailure(
            'Authentication failed. Check username and password.');
      } else if (e.type == DioExceptionType.connectionTimeout ||
          e.type == DioExceptionType.receiveTimeout) {
        throw const ServerFailure(
            'Connection timed out. Check IP and that RESTCONF is enabled.');
      } else {
        throw ServerFailure(
            'RESTCONF error: ${e.message ?? 'Unknown Dio error'}');
      }
    } catch (e) {
      throw ServerFailure('An unknown error occurred: ${e.toString()}');
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\repositories\device_repository_impl.dart ---

// lib/data/repositories/device_repository_impl.dart
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/data/datasources/remote_datasource.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';

class DeviceRepositoryImpl implements DeviceRepository {
  final RemoteDataSource remoteDataSource;

  DeviceRepositoryImpl({required this.remoteDataSource});

  @override
  Future<void> checkCredentials(DeviceCredentials credentials) async {
    if (credentials.type == ConnectionType.ssh ||
        credentials.type == ConnectionType.telnet) {
      try {
        await remoteDataSource.fetchInterfaces(credentials);
      } on ServerFailure catch (e) {
        throw ServerFailure(e.message);
      } catch (e) {
        throw ServerFailure(e.toString());
      }
    } else if (credentials.type == ConnectionType.restApi) {
      return await remoteDataSource.checkRestApiCredentials(credentials);
    }
  }

  @override
  Future<List<RouterInterface>> getInterfaces(
      DeviceCredentials credentials) async {
    try {
      return await remoteDataSource.fetchInterfaces(credentials);
    } on ServerFailure catch (e) {
      throw ServerFailure(e.message);
    } catch (e) {
      throw ServerFailure(e.toString());
    }
  }

  @override
  Future<String> getRoutingTable(DeviceCredentials credentials) async {
    try {
      return await remoteDataSource.getRoutingTable(credentials);
    } on ServerFailure catch (e) {
      return e.message;
    } catch (e) {
      return e.toString();
    }
  }

  // Add the pingGateway implementation back
  @override
  Future<String> pingGateway(
      {required DeviceCredentials credentials,
      required String ipAddress}) async {
    try {
      return await remoteDataSource.pingGateway(credentials, ipAddress);
    } on ServerFailure catch (e) {
      return e.message;
    } catch (e) {
      return e.toString();
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\entities\device_credentials.dart ---

// domain/entities/device_credentials.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';

class DeviceCredentials extends Equatable {
  final String ip;
  final String username;
  final String password;
  final String? enablePassword;
  final ConnectionType type;

  const DeviceCredentials({
    required this.ip,
    required this.username,
    required this.password,
    this.enablePassword,
    required this.type,
  });

  @override
  List<Object?> get props => [ip, username, password, enablePassword, type];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\entities\router_interface.dart ---

// domain/entities/router_interface.dart
import 'package:equatable/equatable.dart';

class RouterInterface extends Equatable {
  final String name;
  final String ipAddress;
  final String status;

  const RouterInterface({
    required this.name,
    required this.ipAddress,
    required this.status,
  });

  @override
  List<Object?> get props => [name, ipAddress, status];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\repositories\device_repository.dart ---

// lib/domain/repositories/device_repository.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';

abstract class DeviceRepository {
  Future<void> checkCredentials(DeviceCredentials credentials);
  Future<List<RouterInterface>> getInterfaces(DeviceCredentials credentials);
  Future<String> getRoutingTable(DeviceCredentials credentials);
  // Add the pingGateway method back to the repository interface
  Future<String> pingGateway({
    required DeviceCredentials credentials,
    required String ipAddress,
  });
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\check_credentials.dart ---


// domain/usecases/check_credentials.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class CheckCredentials {
  final DeviceRepository repository;

  CheckCredentials(this.repository);

  Future<void> call(DeviceCredentials credentials) async {
    return await repository.checkCredentials(credentials);
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\get_interfaces.dart ---

// domain/usecases/get_interfaces.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class GetInterfaces {
  final DeviceRepository repository;

  GetInterfaces(this.repository);

  Future<List<RouterInterface>> call(DeviceCredentials credentials) async {
    return await repository.getInterfaces(credentials);
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\get_routing_table.dart ---

// domain/usecases/get_routing_table.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class GetRoutingTable {
  final DeviceRepository repository;

  GetRoutingTable(this.repository);

  Future<String> call(DeviceCredentials credentials) async {
    return await repository.getRoutingTable(credentials);
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\ping_gateway.dart ---

// lib/domain/usecases/ping_gateway.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class PingGateway {
  final DeviceRepository repository;

  PingGateway(this.repository);

  // The call method now requires credentials again.
  Future<String> call({
    required DeviceCredentials credentials,
    required String ipAddress,
  }) async {
    return await repository.pingGateway(
      credentials: credentials,
      ipAddress: ipAddress,
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\connection\connection_bloc.dart ---

// presentation/bloc/connection/connection_bloc.dart
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/usecases/check_credentials.dart';
import 'connection_event.dart';
import 'connection_state.dart';

class ConnectionBloc extends Bloc<ConnectionEvent, ConnectionState> {
  final CheckCredentials checkCredentials;

  ConnectionBloc({required this.checkCredentials}) : super(ConnectionInitial()) {
    on<CheckCredentialsRequested>(_onCheckCredentials);
  }

  Future<void> _onCheckCredentials(
    CheckCredentialsRequested event,
    Emitter<ConnectionState> emit,
  ) async {
    emit(ConnectionLoading());
    try {
      final credentials = DeviceCredentials(
        ip: event.ip,
        username: event.username,
        password: event.password,
        enablePassword: event.enablePassword,
        type: event.type,
      );
      await checkCredentials(credentials);

      // Pass the credentials object in the success state
      emit(ConnectionSuccess(credentials));
    } on ServerFailure catch (e) {
      emit(ConnectionFailure(e.message));
    } catch (e) {
      emit(ConnectionFailure("An unexpected error occurred: ${e.toString()}"));
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\connection\connection_event.dart ---

// presentation/bloc/connection/connection_event.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';

abstract class ConnectionEvent extends Equatable {
  const ConnectionEvent();

  @override
  List<Object?> get props => [];
}

class CheckCredentialsRequested extends ConnectionEvent {
  final String ip;
  final String username;
  final String password;
  final String? enablePassword;
  final ConnectionType type;

  const CheckCredentialsRequested({
    required this.ip,
    required this.username,
    required this.password,
    this.enablePassword,
    required this.type,
  });

  @override
  List<Object?> get props => [ip, username, password, enablePassword, type];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\connection\connection_state.dart ---

// presentation/bloc/connection/connection_state.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';

abstract class ConnectionState extends Equatable {
  const ConnectionState();

  @override
  List<Object> get props => [];
}

class ConnectionInitial extends ConnectionState {}

class ConnectionLoading extends ConnectionState {}

// Now holds the credentials on success to pass them to the next screen
class ConnectionSuccess extends ConnectionState {
  final DeviceCredentials credentials;
  const ConnectionSuccess(this.credentials);

  @override
  List<Object> get props => [credentials];
}

class ConnectionFailure extends ConnectionState {
  final String error;

  const ConnectionFailure(this.error);

  @override
  List<Object> get props => [error];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\load_balancing\load_balancing_bloc.dart ---

// lib/presentation/bloc/load_balancing/load_balancing_bloc.dart
import 'dart:async';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/usecases/get_interfaces.dart';
import 'package:load_balance/domain/usecases/get_routing_table.dart';
import 'package:load_balance/domain/usecases/ping_gateway.dart';
import 'load_balancing_event.dart';
import 'load_balancing_state.dart';

class LoadBalancingBloc extends Bloc<LoadBalancingEvent, LoadBalancingState> {
  final GetInterfaces getInterfaces;
  final GetRoutingTable getRoutingTable;
  final PingGateway pingGateway;

  LoadBalancingBloc({
    required this.getInterfaces,
    required this.getRoutingTable,
    required this.pingGateway,
  }) : super(const LoadBalancingState()) {
    on<ScreenStarted>(_onScreenStarted);
    on<FetchInterfacesRequested>(_onFetchInterfaces);
    on<FetchRoutingTableRequested>(_onFetchRoutingTable);
    on<PingGatewayRequested>(_onPingGateway);
    on<LoadBalancingTypeSelected>(
      (event, emit) => emit(state.copyWith(type: event.type)),
    );
    on<ApplyEcmpConfig>(_onApplyEcmpConfig);
  }

  void _onScreenStarted(ScreenStarted event, Emitter<LoadBalancingState> emit) {
    emit(state.copyWith(credentials: event.credentials));
    add(FetchInterfacesRequested());
  }

  Future<void> _onFetchInterfaces(
    FetchInterfacesRequested event,
    Emitter<LoadBalancingState> emit,
  ) async {
    if (state.credentials == null) return;
    emit(state.copyWith(interfacesStatus: DataStatus.loading));
    try {
      final interfaces = await getInterfaces(state.credentials!);
      emit(
        state.copyWith(
          interfaces: interfaces,
          interfacesStatus: DataStatus.success,
        ),
      );
    } on ServerFailure catch (e) {
      emit(
        state.copyWith(interfacesStatus: DataStatus.failure, error: e.message),
      );
    }
  }

  Future<void> _onFetchRoutingTable(
    FetchRoutingTableRequested event,
    Emitter<LoadBalancingState> emit,
  ) async {
    if (state.credentials == null) return;
    emit(
      state.copyWith(
        routingTableStatus: DataStatus.loading,
        clearRoutingTable: true,
      ),
    );
    try {
      final table = await getRoutingTable(state.credentials!);
      emit(
        state.copyWith(
          routingTable: table,
          routingTableStatus: DataStatus.success,
        ),
      );
    } on ServerFailure catch (e) {
      emit(
        state.copyWith(
          routingTable: e.message,
          routingTableStatus: DataStatus.failure,
        ),
      );
    }
  }

  Future<void> _onPingGateway(
    PingGatewayRequested event,
    Emitter<LoadBalancingState> emit,
  ) async {
    // The BLoC now needs to pass the credentials to the use case.
    if (state.credentials == null) return;
    emit(
      state.copyWith(
        pingStatus: DataStatus.loading,
        pingingIp: event.ipAddress,
      ),
    );
    final result = await pingGateway(
      credentials: state.credentials!,
      ipAddress: event.ipAddress,
    );
    final newPingResults = Map<String, String>.from(state.pingResults);
    newPingResults[event.ipAddress] = result;
    emit(
      state.copyWith(
        pingResults: newPingResults,
        pingStatus: DataStatus.success,
        pingingIp: '',
      ),
    );
  }

  Future<void> _onApplyEcmpConfig(
    ApplyEcmpConfig event,
    Emitter<LoadBalancingState> emit,
  ) async {
    // Logic to apply ECMP config will go here.
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\load_balancing\load_balancing_event.dart ---

// lib/presentation/bloc/load_balancing/load_balancing_event.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart';

abstract class LoadBalancingEvent extends Equatable {
  const LoadBalancingEvent();
  @override
  List<Object?> get props => [];
}

class ScreenStarted extends LoadBalancingEvent {
  final DeviceCredentials credentials;
  const ScreenStarted(this.credentials);
  @override
  List<Object?> get props => [credentials];
}

class LoadBalancingTypeSelected extends LoadBalancingEvent {
  final LoadBalancingType type;
  const LoadBalancingTypeSelected(this.type);
  @override
  List<Object> get props => [type];
}

class FetchInterfacesRequested extends LoadBalancingEvent {}
class FetchRoutingTableRequested extends LoadBalancingEvent {}

class PingGatewayRequested extends LoadBalancingEvent {
  final String ipAddress;
  const PingGatewayRequested(this.ipAddress);
  @override
  List<Object?> get props => [ipAddress];
}

class ApplyEcmpConfig extends LoadBalancingEvent {
  final String gateway1;
  final String gateway2;
  const ApplyEcmpConfig({required this.gateway1, required this.gateway2});
  @override
  List<Object> get props => [gateway1, gateway2];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\load_balancing\load_balancing_state.dart ---

// lib/presentation/bloc/load_balancing/load_balancing_state.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';

enum LoadBalancingType { ecmp, pbr }
enum DataStatus { initial, loading, success, failure }

class LoadBalancingState extends Equatable {
  final DeviceCredentials? credentials; // Holds the credentials to be used for each request
  final LoadBalancingType type;
  final DataStatus status;
  final String error;

  final List<RouterInterface> interfaces;
  final DataStatus interfacesStatus;

  final String? routingTable;
  final DataStatus routingTableStatus;

  final Map<String, String> pingResults;
  final DataStatus pingStatus;
  final String? pingingIp;

  const LoadBalancingState({
    this.credentials,
    this.type = LoadBalancingType.ecmp,
    this.status = DataStatus.initial,
    this.error = '',
    this.interfaces = const [],
    this.interfacesStatus = DataStatus.initial,
    this.routingTable,
    this.routingTableStatus = DataStatus.initial,
    this.pingResults = const {},
    this.pingStatus = DataStatus.initial,
    this.pingingIp,
  });

  LoadBalancingState copyWith({
    DeviceCredentials? credentials,
    LoadBalancingType? type,
    DataStatus? status,
    String? error,
    List<RouterInterface>? interfaces,
    DataStatus? interfacesStatus,
    String? routingTable,
    DataStatus? routingTableStatus,
    Map<String, String>? pingResults,
    DataStatus? pingStatus,
    String? pingingIp,
    bool clearRoutingTable = false,
  }) {
    return LoadBalancingState(
      credentials: credentials ?? this.credentials,
      type: type ?? this.type,
      status: status ?? this.status,
      error: error ?? this.error,
      interfaces: interfaces ?? this.interfaces,
      interfacesStatus: interfacesStatus ?? this.interfacesStatus,
      routingTable: clearRoutingTable ? null : routingTable ?? this.routingTable,
      routingTableStatus: routingTableStatus ?? this.routingTableStatus,
      pingResults: pingResults ?? this.pingResults,
      pingStatus: pingStatus ?? this.pingStatus,
      pingingIp: pingingIp ?? this.pingingIp,
    );
  }

  @override
  List<Object?> get props => [
        credentials, type, status, error, interfaces, interfacesStatus,
        routingTable, routingTableStatus, pingResults, pingStatus, pingingIp
      ];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\connection\connection_screen.dart ---

// presentation/screens/connection/connection_screen.dart
import 'package:flutter/material.dart' hide ConnectionState;
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:load_balance/presentation/bloc/connection/connection_bloc.dart';
import 'package:load_balance/presentation/bloc/connection/connection_event.dart';
import 'package:load_balance/presentation/bloc/connection/connection_state.dart';

enum ConnectionType { ssh, telnet, restApi }

class ConnectionScreen extends StatefulWidget {
  const ConnectionScreen({super.key});

  @override
  State<ConnectionScreen> createState() => _ConnectionScreenState();
}

class _ConnectionScreenState extends State<ConnectionScreen> {
  final _formKey = GlobalKey<FormState>();
  final _ipController = TextEditingController();
  final _usernameController = TextEditingController();
  final _passwordController = TextEditingController();
  final _enablePasswordController = TextEditingController();
  bool _isPasswordVisible = false;
  bool _isEnablePasswordVisible = false;

  ConnectionType _selectedType = ConnectionType.ssh;

  @override
  void dispose() {
    _ipController.dispose();
    _usernameController.dispose();
    _passwordController.dispose();
    _enablePasswordController.dispose();
    super.dispose();
  }

  void _checkCredentials() {
    if (_formKey.currentState!.validate()) {
      context.read<ConnectionBloc>().add(
            CheckCredentialsRequested(
              ip: _ipController.text,
              username: _usernameController.text,
              password: _passwordController.text,
              enablePassword: _enablePasswordController.text,
              type: _selectedType,
            ),
          );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Router Connection'),
      ),
      body: BlocListener<ConnectionBloc, ConnectionState>(
        listener: (context, state) {
          if (state is ConnectionSuccess) {
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(
                const SnackBar(
                  content: Text('Connection Successful!'),
                  backgroundColor: Colors.green,
                ),
              );
            // Navigate and pass credentials to the next screen
            context.go('/config', extra: state.credentials);
          } else if (state is ConnectionFailure) {
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(
                SnackBar(
                  content: Text('Error: ${state.error}'),
                  backgroundColor: Colors.red,
                ),
              );
          }
        },
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24.0),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(
                    'Enter Router Credentials',
                    style: Theme.of(context).textTheme.headlineSmall,
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 32),
                  TextFormField(
                    controller: _ipController,
                    decoration: const InputDecoration(
                      labelText: 'IP Address',
                      prefixIcon: Icon(Icons.router),
                    ),
                    keyboardType: TextInputType.number,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please enter an IP address';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _usernameController,
                    decoration: const InputDecoration(
                      labelText: 'Username',
                      prefixIcon: Icon(Icons.person),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please enter a username';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _passwordController,
                    obscureText: !_isPasswordVisible,
                    decoration: InputDecoration(
                      labelText: 'Password',
                      prefixIcon: const Icon(Icons.lock_outline),
                      suffixIcon: IconButton(
                        icon: Icon(_isPasswordVisible
                            ? Icons.visibility_off
                            : Icons.visibility),
                        onPressed: () => setState(
                            () => _isPasswordVisible = !_isPasswordVisible),
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please enter a password';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  Visibility(
                    visible: _selectedType != ConnectionType.restApi,
                    child: TextFormField(
                      controller: _enablePasswordController,
                      obscureText: !_isEnablePasswordVisible,
                      decoration: InputDecoration(
                        labelText: 'Enable Password (optional)',
                        prefixIcon: const Icon(Icons.lock),
                        suffixIcon: IconButton(
                          icon: Icon(_isEnablePasswordVisible
                              ? Icons.visibility_off
                              : Icons.visibility),
                          onPressed: () => setState(() =>
                              _isEnablePasswordVisible =
                                  !_isEnablePasswordVisible),
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 24),
                  SegmentedButton<ConnectionType>(
                    segments: const <ButtonSegment<ConnectionType>>[
                      ButtonSegment<ConnectionType>(
                          value: ConnectionType.ssh,
                          label: Text('SSHv2'),
                          icon: Icon(Icons.security)),
                      ButtonSegment<ConnectionType>(
                          value: ConnectionType.telnet,
                          label: Text('Telnet'),
                          icon: Icon(Icons.lan)),
                      ButtonSegment<ConnectionType>(
                          value: ConnectionType.restApi,
                          label: Text('REST API'),
                          icon: Icon(Icons.http)),
                    ],
                    selected: {_selectedType},
                    onSelectionChanged: (Set<ConnectionType> newSelection) {
                      setState(() {
                        _selectedType = newSelection.first;
                      });
                    },
                  ),
                  const SizedBox(height: 32),
                  BlocBuilder<ConnectionBloc, ConnectionState>(
                    builder: (context, state) {
                      if (state is ConnectionLoading) {
                        return const Center(child: CircularProgressIndicator());
                      }
                      return ElevatedButton.icon(
                        icon: const Icon(Icons.login),
                        label: const Text('Check Credential'),
                        onPressed: _checkCredentials,
                        style: ElevatedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          textStyle: const TextStyle(fontSize: 16),
                        ),
                      );
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\load_balancing\load_balancing_screen.dart ---

// lib/presentation/screens/load_balancing/load_balancing_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_event.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart';
import 'package:load_balance/presentation/screens/load_balancing/widgets/ecmp_form.dart';
import 'package:load_balance/presentation/screens/load_balancing/widgets/pbr_form.dart';

class LoadBalancingScreen extends StatefulWidget {
  final DeviceCredentials credentials;
  const LoadBalancingScreen({super.key, required this.credentials});

  @override
  State<LoadBalancingScreen> createState() => _LoadBalancingScreenState();
}

class _LoadBalancingScreenState extends State<LoadBalancingScreen> {
  @override
  void initState() {
    super.initState();
    // Start the process by passing credentials to the BLoC.
    context.read<LoadBalancingBloc>().add(ScreenStarted(widget.credentials));
  }

  // The dispose method is no longer needed to manage the connection.
  @override
  void dispose() {
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Load Balancing Configuration'),
      ),
      body: BlocListener<LoadBalancingBloc, LoadBalancingState>(
        listener: (context, state) {
          if (state.status == DataStatus.success) {
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(
                const SnackBar(
                  content: Text('Configuration Applied Successfully!'),
                  backgroundColor: Colors.green,
                ),
              );
          } else if (state.status == DataStatus.failure) {
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(
                SnackBar(
                  content: Text('Error: ${state.error}'),
                  backgroundColor: Colors.red,
                ),
              );
          }
        },
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Text(
                'Select Load Balancing Method',
                style: Theme.of(context).textTheme.titleLarge,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),
              BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
                builder: (context, state) {
                  return SegmentedButton<LoadBalancingType>(
                    segments: const <ButtonSegment<LoadBalancingType>>[
                      ButtonSegment<LoadBalancingType>(
                        value: LoadBalancingType.ecmp,
                        label: Text('ECMP'),
                        icon: Icon(Icons.alt_route),
                      ),
                      ButtonSegment<LoadBalancingType>(
                        value: LoadBalancingType.pbr,
                        label: Text('PBR'),
                        icon: Icon(Icons.rule),
                      ),
                    ],
                    selected: {state.type},
                    onSelectionChanged: (Set<LoadBalancingType> newSelection) {
                      context
                          .read<LoadBalancingBloc>()
                          .add(LoadBalancingTypeSelected(newSelection.first));
                    },
                  );
                },
              ),
              const SizedBox(height: 24),
              const _RouterInfoSection(), // Widget for smart features
              const SizedBox(height: 24),
              BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
                builder: (context, state) {
                  if (state.type == LoadBalancingType.ecmp) {
                    return const EcmpForm();
                  } else {
                    return const PbrForm();
                  }
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// A private widget to display router info (Interfaces and Routing Table)
class _RouterInfoSection extends StatelessWidget {
  const _RouterInfoSection();

  @override
  Widget build(BuildContext context) {
    final state = context.watch<LoadBalancingBloc>().state;

    return Card(
      clipBehavior: Clip.antiAlias,
      child: ExpansionTile(
        initiallyExpanded: true,
        title: const Text('Router Information'),
        subtitle: const Text('View interfaces and routing table'),
        children: [
          _buildInterfacesInfo(context, state),
          const Divider(height: 1),
          _buildRoutingTableInfo(context, state),
        ],
      ),
    );
  }

  Widget _buildInterfacesInfo(
      BuildContext context, LoadBalancingState state) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Text('Device Interfaces',
                style: Theme.of(context).textTheme.titleMedium),
          ),
          const SizedBox(height: 8),
          if (state.interfacesStatus == DataStatus.loading)
            const Center(child: CircularProgressIndicator())
          else if (state.interfacesStatus == DataStatus.failure)
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Text('Error fetching interfaces: ${state.error}',
                  style: const TextStyle(color: Colors.red)),
            )
          else if (state.interfaces.isEmpty)
            const Padding(
              padding: EdgeInsets.symmetric(horizontal: 16.0),
              child: Text('No active interfaces found or connection failed.'),
            )
          else
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: DataTable(
                columns: const [
                  DataColumn(label: Text('Interface')),
                  DataColumn(label: Text('IP Address')),
                  DataColumn(label: Text('Status')),
                ],
                rows: state.interfaces
                    .map((iface) => DataRow(
                          cells: [
                            DataCell(Text(iface.name)),
                            DataCell(Text(iface.ipAddress)),
                            DataCell(Text(
                              iface.status,
                              style: TextStyle(
                                  color: iface.status == 'up'
                                      ? Colors.green
                                      : Colors.orange),
                            )),
                          ],
                        ))
                    .toList(),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildRoutingTableInfo(
      BuildContext context, LoadBalancingState state) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text('IP Routing Table',
                  style: Theme.of(context).textTheme.titleMedium),
              if (state.routingTableStatus != DataStatus.loading)
                IconButton(
                  icon: const Icon(Icons.refresh),
                  tooltip: 'Refresh Routing Table',
                  // FIX: The button is enabled as long as we have credentials.
                  onPressed: state.credentials == null
                      ? null
                      : () {
                          context
                              .read<LoadBalancingBloc>()
                              .add(FetchRoutingTableRequested());
                        },
                )
              else
                const SizedBox(
                    height: 24,
                    width: 24,
                    child: CircularProgressIndicator(strokeWidth: 2)),
            ],
          ),
          const SizedBox(height: 8),
          if (state.routingTableStatus == DataStatus.loading &&
              state.routingTable == null)
            const Center(child: Text('Fetching...'))
          else if (state.routingTable != null)
            Container(
              padding: const EdgeInsets.all(8),
              color: Colors.black.withAlpha((255 * 0.3).round()),
              width: double.infinity,
              child: SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: Text(
                  state.routingTable!,
                  style: const TextStyle(fontFamily: 'monospace', fontSize: 12),
                ),
              ),
            )
          else
            const Text('Press refresh to view the routing table.'),
        ],
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\load_balancing\widgets\ecmp_form.dart ---

// lib/presentation/screens/load_balancing/widgets/ecmp_form.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_event.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart';

class EcmpForm extends StatefulWidget {
  const EcmpForm({super.key});

  @override
  State<EcmpForm> createState() => _EcmpFormState();
}

class _EcmpFormState extends State<EcmpForm> {
  final _formKey = GlobalKey<FormState>();
  final _gateway1Controller = TextEditingController();
  final _gateway2Controller = TextEditingController();

  @override
  void dispose() {
    _gateway1Controller.dispose();
    _gateway2Controller.dispose();
    super.dispose();
  }

  void _applyEcmpConfig() {
    if (_formKey.currentState!.validate()) {
      context.read<LoadBalancingBloc>().add(
            ApplyEcmpConfig(
              gateway1: _gateway1Controller.text,
              gateway2: _gateway2Controller.text,
            ),
          );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Text(
                'ECMP Configuration',
                style: Theme.of(context).textTheme.headlineSmall,
              ),
              const SizedBox(height: 8),
              const Text(
                  'Enter the gateway IPs for your two internet connections. Traffic will be distributed equally.'),
              const SizedBox(height: 24),
              // Use the new dedicated widget for the input field
              _GatewayInputField(
                controller: _gateway1Controller,
                labelText: 'Gateway IP 1',
                hintText: 'e.g., 203.0.113.1',
              ),
              const SizedBox(height: 16),
              // Use the new dedicated widget for the input field
              _GatewayInputField(
                controller: _gateway2Controller,
                labelText: 'Gateway IP 2',
                hintText: 'e.g., 198.51.100.1',
              ),
              const SizedBox(height: 32),
              BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
                builder: (context, state) {
                  if (state.status == DataStatus.loading) {
                    return const Center(child: CircularProgressIndicator());
                  }
                  return ElevatedButton.icon(
                    onPressed: _applyEcmpConfig,
                    icon: const Icon(Icons.check_circle_outline),
                    label: const Text('Apply Configuration'),
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                  );
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// A dedicated, stateless widget for the gateway input field.
/// This improves reliability by isolating the build logic.
class _GatewayInputField extends StatelessWidget {
  final TextEditingController controller;
  final String labelText;
  final String hintText;

  const _GatewayInputField({
    required this.controller,
    required this.labelText,
    required this.hintText,
  });

  @override
  Widget build(BuildContext context) {
    // Use a BlocBuilder to react to state changes for this specific field.
    return BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
      builder: (context, state) {
        final ip = controller.text;
        final isPinging =
            state.pingStatus == DataStatus.loading && state.pingingIp == ip;
        final pingResult = state.pingResults[ip];

        return TextFormField(
          controller: controller,
          // Use a ValueListenableBuilder to enable/disable the button
          // based on whether the text field is empty or not. This is more efficient.
          decoration: InputDecoration(
            labelText: labelText,
            hintText: hintText,
            suffixIcon: isPinging
                ? const Padding(
                    padding: EdgeInsets.all(12.0),
                    child: SizedBox(
                        height: 24,
                        width: 24,
                        child: CircularProgressIndicator(strokeWidth: 2.5)),
                  )
                : ValueListenableBuilder<TextEditingValue>(
                    valueListenable: controller,
                    builder: (context, value, child) {
                      return IconButton(
                        icon: const Icon(Icons.network_ping),
                        tooltip: 'Test Gateway Reachability',
                        onPressed: value.text.isNotEmpty
                            ? () {
                                debugPrint('--- PING BUTTON PRESSED for IP: $ip ---');
                                context
                                    .read<LoadBalancingBloc>()
                                    .add(PingGatewayRequested(ip));
                              }
                            : null,
                      );
                    },
                  ),
            helperText: pingResult,
            helperStyle: TextStyle(
              color: pingResult != null && pingResult.contains('Success')
                  ? Colors.green
                  : Colors.orange,
            ),
          ),
          keyboardType: TextInputType.number,
          validator: (value) =>
              value == null || value.isEmpty ? 'Please enter a Gateway IP' : null,
        );
      },
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\load_balancing\widgets\pbr_form.dart ---


// presentation/screens/load_balancing/widgets/pbr_form.dart
import 'package:flutter/material.dart';

class PbrForm extends StatefulWidget {
  const PbrForm({super.key});

  @override
  State<PbrForm> createState() => _PbrFormState();
}

class _PbrFormState extends State<PbrForm> {
  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              'PBR Configuration',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            const Text(
                'Define policies to route specific traffic through different gateways. (Coming Soon)'),
            const SizedBox(height: 24),
            // UI elements for PBR will be added here
            const Center(
              child: Text(
                'PBR configuration UI is under development.',
                style: TextStyle(fontStyle: FontStyle.italic),
              ),
            ),
            const SizedBox(height: 32),
            ElevatedButton.icon(
              onPressed: null, // Disabled for now
              icon: const Icon(Icons.check_circle_outline),
              label: const Text('Apply Configuration'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 16),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
