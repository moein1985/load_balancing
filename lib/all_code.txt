
--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\injection_container.dart ---

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/data/datasources/remote_datasource_impl.dart';
import 'package:load_balance/data/repositories/device_repository_impl.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';
import 'package:load_balance/domain/usecases/apply_ecmp_config.dart';
import 'package:load_balance/domain/usecases/check_credentials.dart';
import 'package:load_balance/domain/usecases/get_interfaces.dart';
import 'package:load_balance/domain/usecases/get_routing_table.dart';
import 'package:load_balance/domain/usecases/ping_gateway.dart';
import 'package:load_balance/presentation/bloc/connection/connection_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_bloc.dart';
import 'package:load_balance/presentation/bloc/pbr_rule_form/pbr_rule_form_bloc.dart';

class DependencyInjector extends StatelessWidget {
  final Widget child;

  const DependencyInjector({super.key, required this.child});

  @override
  Widget build(BuildContext context) {
    return RepositoryProvider<DeviceRepository>(
      create: (context) => DeviceRepositoryImpl(
        remoteDataSource: RemoteDataSourceImpl(),
      ),
      child: MultiBlocProvider(
        providers: [
          BlocProvider(
            create: (context) => ConnectionBloc(
              checkCredentials: CheckCredentials(context.read<DeviceRepository>()),
            ),
          ),
          BlocProvider(
            create: (context) {
              final repository = context.read<DeviceRepository>();
              return LoadBalancingBloc(
                getInterfaces: GetInterfaces(repository),
                getRoutingTable: GetRoutingTable(repository),
                pingGateway: PingGateway(repository),
                applyEcmpConfig: ApplyEcmpConfig(repository),
              );
            },
          ),
          BlocProvider(
            create: (context) => PbrRuleFormBloc(),
          ),
        ],
        child: child, // The MaterialApp will be passed here
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\main.dart ---

import 'package:flutter/material.dart';
import 'package:load_balance/core/router/app_router.dart';
import 'package:load_balance/injection_container.dart'; // Import the new file

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    // Wrap the entire app with the DependencyInjector
    return DependencyInjector(
      child: MaterialApp.router(
        title: 'Cisco Load Balancer',
        theme: ThemeData(
          primarySwatch: Colors.blue,
          useMaterial3: true,
          brightness: Brightness.dark,
          cardTheme: CardThemeData(elevation: 2, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0))),
          // This line is corrected from your error log
          inputDecorationTheme: const InputDecorationTheme(border: OutlineInputBorder(borderRadius: BorderRadius.all(Radius.circular(12.0)))),
          segmentedButtonTheme: SegmentedButtonThemeData(
            style: ButtonStyle(shape: WidgetStateProperty.all(RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)))),
          ),
        ),
        routerConfig: AppRouter.router,
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\test.dart ---

// import 'package:dart_ping/dart_ping.dart';

// void main() async {
//   // Create ping object with desired args
//   final ping = Ping('google.com', count: 5);

//   // [Optional]
//   // Preview command that will be run (helpful for debugging)
//   print('Running command: ${ping.command}');

//   // Begin ping process and listen for output
//   ping.stream.listen((event) {
//     print(event);
//   });
// }

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\core\error\failure.dart ---

// core/error/failure.dart
import 'package:equatable/equatable.dart';

abstract class Failure extends Equatable {
  final String message;
  const Failure(this.message);

  @override
  List<Object> get props => [message];
}

// Failure specific to server/connection errors
class ServerFailure extends Failure {
  const ServerFailure(super.message);
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\core\router\app_router.dart ---

// lib/core/router/app_router.dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/presentation/screens/load_balancing/add_edit_pbr_rule_screen.dart';
import 'package:load_balance/presentation/screens/load_balancing/load_balancing_screen.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';

class AppRouter {
  static final GoRouter router = GoRouter(
    initialLocation: '/',
    routes: [
      GoRoute(
        path: '/',
        name: 'connection',
        builder: (BuildContext context, GoRouterState state) {
          return const ConnectionScreen();
        },
      ),
      GoRoute(
        path: '/config',
        name: 'config',
        builder: (BuildContext context, GoRouterState state) {
          // این بخش بدون تغییر باقی میماند
          final credentials = state.extra as DeviceCredentials;
          return LoadBalancingScreen(credentials: credentials);
        },
        routes: [
          GoRoute(
            path: 'add-pbr-rule',
            name: 'add_pbr_rule',
            builder: (BuildContext context, GoRouterState state) {
              // **تغییر اصلی:** حالا extra را برای این صفحه هم میخوانیم
              final credentials = state.extra as DeviceCredentials?;
              return AddEditPbrRuleScreen(credentials: credentials);
            },
          ),
          GoRoute(
            path: 'edit-pbr-rule/:ruleId',
            name: 'edit_pbr_rule',
            builder: (BuildContext context, GoRouterState state) {
              final ruleId = state.pathParameters['ruleId'];
              final credentials = state.extra as DeviceCredentials?;
              return AddEditPbrRuleScreen(credentials: credentials, ruleId: ruleId);
            },
          ),
        ],
      ),
    ],
  );
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\core\usecase\usecase.dart ---


--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\datasources\remote_datasource.dart ---

// lib/data/datasources/remote_datasource.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/pbr_rule.dart';
import 'package:load_balance/domain/entities/router_interface.dart';

abstract class RemoteDataSource {
  Future<void> checkRestApiCredentials(DeviceCredentials credentials);
  Future<List<RouterInterface>> fetchInterfaces(DeviceCredentials credentials);
  Future<String> getRoutingTable(DeviceCredentials credentials);
  Future<String> pingGateway(DeviceCredentials credentials, String ipAddress);
  Future<String> applyEcmpConfig({
    required DeviceCredentials credentials,
    required List<String> gatewaysToAdd,
    required List<String> gatewaysToRemove,
  });
  Future<String> applyPbrRule({
    required DeviceCredentials credentials,
    required PbrRule rule,
  });
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\datasources\remote_datasource_impl.dart ---

// lib/data/datasources/remote_datasource_impl.dart
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/pbr_rule.dart';
import 'package:load_balance/domain/entities/router_interface.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';
import 'package:load_balance/data/datasources/ssh_client_handler.dart';
import 'package:load_balance/data/datasources/telnet_client_handler.dart';
import 'package:load_balance/data/datasources/restapi_client_handler.dart';
import 'remote_datasource.dart';

class RemoteDataSourceImpl implements RemoteDataSource {
  final SshClientHandler _sshHandler = SshClientHandler();
  final TelnetClientHandler _telnetHandler = TelnetClientHandler();
  final RestApiClientHandler _restApiHandler = RestApiClientHandler();

  // A short delay to prevent overwhelming the router with rapid connections.
  static const Duration _networkDelay = Duration(seconds: 2);

  void _logDebug(String message) {
    if (kDebugMode) {
      debugPrint('[REMOTE_DS] $message');
    }
  }

  @override
  Future<List<RouterInterface>> fetchInterfaces(
    DeviceCredentials credentials,
  ) async {
    _logDebug('Fetching interface list - ${credentials.type}');
    String briefResult;
    String detailedResult;

    if (credentials.type == ConnectionType.ssh) {
      briefResult = await _sshHandler.fetchInterfaces(credentials);
      detailedResult = await _sshHandler.fetchDetailedInterfaces(credentials);
    } else {
      // ADDED: Delay before Telnet operations
      await Future.delayed(_networkDelay);
      briefResult = await _telnetHandler.fetchInterfaces(credentials);

      await Future.delayed(_networkDelay);
      detailedResult = await _telnetHandler.fetchDetailedInterfaces(
        credentials,
      );
    }

    return _parseDetailedInterfaces(briefResult, detailedResult);
  }

  List<RouterInterface> _parseDetailedInterfaces(
    String briefResult,
    String detailedResult,
  ) {
    final interfaces = <RouterInterface>[];
    final briefLines = briefResult.split('\n');
    final briefRegex = RegExp(
      r'^(\S+)\s+([\d\.]+|unassigned)\s+\w+\s+\w+\s+(up|down|administratively down)',
    );
    // First, find the main interfaces from the brief output
    final mainInterfaces = <Map<String, String>>[];
    for (final line in briefLines) {
      final match = briefRegex.firstMatch(line);
      if (match != null && match.group(2) != 'unassigned') {
        final interfaceName = match.group(1)!;
        // Ignore NVI0 as it's a virtual interface
        if (!interfaceName.startsWith('NVI')) {
          mainInterfaces.add({
            'name': interfaceName,
            'primaryIp': match.group(2)!,
            'status': match.group(3)!,
          });
        }
      }
    }

    // Then, find secondary addresses from the detailed config
    final secondaryIps = _extractSecondaryIps(detailedResult);
    // Build the final interface list
    for (final interface in mainInterfaces) {
      final interfaceName = interface['name']!;
      final primaryIp = interface['primaryIp']!;
      final status = interface['status']!;

      // Add the primary address
      interfaces.add(
        RouterInterface(
          name: interfaceName,
          ipAddress: primaryIp,
          status: status,
        ),
      );
      // Add any secondary addresses
      final secondaries = secondaryIps[interfaceName] ?? [];
      for (final secondaryIp in secondaries) {
        interfaces.add(
          RouterInterface(
            name: '$interfaceName (Secondary)',
            ipAddress: secondaryIp,
            status: status,
          ),
        );
      }
    }

    _logDebug('${interfaces.length} interfaces processed');
    return interfaces;
  }

  Map<String, List<String>> _extractSecondaryIps(String configOutput) {
    final secondaryIps = <String, List<String>>{};
    final lines = configOutput.split('\n');
    String? currentInterface;

    for (final line in lines) {
      final trimmedLine = line.trim();
      // Find the start of an interface configuration
      if (trimmedLine.startsWith('interface ')) {
        currentInterface = trimmedLine.split(' ')[1];
        secondaryIps[currentInterface] = [];
      }

      // Find secondary IP addresses
      if (currentInterface != null &&
          trimmedLine.contains('ip address') &&
          trimmedLine.contains('secondary')) {
        final parts = trimmedLine.split(' ');
        if (parts.length >= 4) {
          final ipAddress = parts[2];
          if (_isValidIpAddress(ipAddress)) {
            secondaryIps[currentInterface]!.add(ipAddress);
          }
        }
      }
    }

    return secondaryIps;
  }

  @override
  Future<String> getRoutingTable(DeviceCredentials credentials) async {
    _logDebug('Fetching routing table - ${credentials.type}');

    String rawResult;
    if (credentials.type == ConnectionType.ssh) {
      rawResult = await _sshHandler.getRoutingTable(credentials);
    } else {
      // ADDED: Delay before Telnet operations
      await Future.delayed(_networkDelay);
      rawResult = await _telnetHandler.getRoutingTable(credentials);
    }

    return _cleanRoutingTableOutput(rawResult);
  }

  String _cleanRoutingTableOutput(String rawResult) {
    _logDebug(
      'Cleaning routing table output, input length: ${rawResult.length}',
    );
    final lines = rawResult.split('\n');
    final cleanLines = <String>[];
    bool routeStarted = false;
    for (final line in lines) {
      final trimmedLine = line.trim();
      // Start of the routing table
      if (trimmedLine.startsWith('Codes:') ||
          trimmedLine.startsWith('Gateway of last resort')) {
        routeStarted = true;
      }

      // End of the routing table (prompt)
      if (routeStarted &&
          (trimmedLine.endsWith('#') || trimmedLine.endsWith('>'))) {
        break;
      }

      if (routeStarted && trimmedLine.isNotEmpty) {
        cleanLines.add(line);
      }
    }

    final result = cleanLines.join('\n').trim();
    _logDebug('Routing table cleaned, length: ${result.length}');
    return result;
  }

  @override
  Future<String> pingGateway(
    DeviceCredentials credentials,
    String ipAddress,
  ) async {
    _logDebug('Starting ping for IP: $ipAddress - ${credentials.type}');
    if (ipAddress.trim().isEmpty) {
      return 'Error: IP address cannot be empty.';
    }

    if (!_isValidIpAddress(ipAddress.trim())) {
      return 'Error: Invalid IP address format.';
    }

    final cleanIp = ipAddress.trim();

    try {
      if (credentials.type == ConnectionType.ssh) {
        return await _sshHandler.pingGateway(credentials, cleanIp);
      } else {
        // ADDED: Delay before Telnet operations
        await Future.delayed(_networkDelay);
        return await _telnetHandler.pingGateway(credentials, cleanIp);
      }
    } catch (e) {
      _logDebug('Error in ping: $e');
      if (e is ServerFailure) {
        return 'Error: ${e.message}';
      }
      return 'Error in ping: ${e.toString()}';
    }
  }

  bool _isValidIpAddress(String ip) {
    final ipRegex = RegExp(r'^(\d{1,3}\.){3}\d{1,3}$');
    if (!ipRegex.hasMatch(ip)) return false;
    final parts = ip.split('.');
    for (final part in parts) {
      final num = int.tryParse(part);
      if (num == null || num < 0 || num > 255) return false;
    }
    return true;
  }

  @override
  Future<void> checkRestApiCredentials(DeviceCredentials credentials) async {
    _logDebug('Checking REST API credentials');
    return await _restApiHandler.checkCredentials(credentials);
  }

  @override
  Future<String> applyEcmpConfig({
    required DeviceCredentials credentials,
    required List<String> gatewaysToAdd,
    required List<String> gatewaysToRemove,
  }) async {
    _logDebug('Applying ECMP config - ${credentials.type}');
    try {
      if (credentials.type == ConnectionType.ssh) {
        return await _sshHandler.applyEcmpConfig(
          credentials: credentials,
          gatewaysToAdd: gatewaysToAdd,
          gatewaysToRemove: gatewaysToRemove,
        );
      } else if (credentials.type == ConnectionType.telnet) {
        // ADDED: Delay before Telnet operations
        await Future.delayed(_networkDelay);
        return await _telnetHandler.applyEcmpConfig(
          credentials: credentials,
          gatewaysToAdd: gatewaysToAdd,
          gatewaysToRemove: gatewaysToRemove,
        );
      } else {
        return 'Configuration via REST API is not yet supported.';
      }
    } on ServerFailure catch (e) {
      _logDebug('ServerFailure applying ECMP config: ${e.message}');
      return e.message;
    } catch (e) {
      _logDebug('Unknown error applying ECMP config: ${e.toString()}');
      return 'An unknown error occurred: ${e.toString()}';
    }
  }

  @override
  Future<String> applyPbrRule({
    required DeviceCredentials credentials,
    required PbrRule rule,
  }) async {
    _logDebug('Applying PBR rule: ${rule.ruleName}');
    try {
      if (credentials.type == ConnectionType.ssh) {
        return await _sshHandler.applyPbrRule(
          credentials: credentials,
          rule: rule,
        );
      } else if (credentials.type == ConnectionType.telnet) {
        await Future.delayed(_networkDelay);
        return await _telnetHandler.applyPbrRule(
          credentials: credentials,
          rule: rule,
        );
      } else {
        return 'PBR Configuration via REST API is not yet supported.';
      }
    } on ServerFailure catch (e) {
      return e.message;
    } catch (e) {
      return 'An unknown error occurred: ${e.toString()}';
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\datasources\restapi_client_handler.dart ---

// lib/data/datasources/restapi_client_handler.dart
import 'dart:convert';
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:dio/io.dart';
import 'package:flutter/foundation.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';

class RestApiClientHandler {
  void _logDebug(String message) {
    if (kDebugMode) {
      debugPrint('[REST API] $message');
    }
  }

  Future<void> checkCredentials(DeviceCredentials credentials) async {
    _logDebug('Checking REST API credentials');
    
    final dio = Dio();
    final String basicAuth = 'Basic ${base64Encode(
        utf8.encode('${credentials.username}:${credentials.password}'))}';
    
    // Allow self-signed certificates for lab environments
    (dio.httpClientAdapter as IOHttpClientAdapter).createHttpClient = () {
      final client = HttpClient();
      client.badCertificateCallback = (cert, host, port) {
        _logDebug('Warning: Untrusted SSL certificate for $host:$port');
        return true;
      };
      return client;
    };

    try {
      final response = await dio.get(
        'https://${credentials.ip}/restconf/data/Cisco-IOS-XE-native:native',
        options: Options(
          headers: {
            'Authorization': basicAuth,
            'Accept': 'application/yang-data+json'
          },
          receiveTimeout: const Duration(seconds: 10),
          sendTimeout: const Duration(seconds: 10),
        ),
      );
      _logDebug('REST API connection successful - Response code: ${response.statusCode}');
    } on DioException catch (e) {
      _logDebug('REST API Error: ${e.type} - ${e.message}');
      if (e.response?.statusCode == 401) {
        throw const ServerFailure(
            'Authentication failed. Check your username and password.');
      } else if (e.type == DioExceptionType.connectionTimeout ||
          e.type == DioExceptionType.receiveTimeout) {
        throw const ServerFailure(
            'Connection timed out. Check the IP and ensure RESTCONF is enabled.');
      } else if (e.type == DioExceptionType.connectionError) {
        throw const ServerFailure(
            'Connection error. Check the IP and network accessibility.');
      } else {
        throw ServerFailure(
            'RESTCONF Error: ${e.message ?? 'Unknown Dio error'}');
      }
    } catch (e) {
      _logDebug('Unknown REST API error: $e');
      throw ServerFailure('An unknown error occurred: ${e.toString()}');
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\datasources\ssh_client_handler.dart ---

// lib/data/datasources/ssh_client_handler.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:dartssh2/dartssh2.dart';
import 'package:flutter/foundation.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/pbr_rule.dart';
import 'package:load_balance/presentation/bloc/pbr_rule_form/pbr_rule_form_state.dart';

class SshClientHandler {
  static const _commandTimeout = Duration(seconds: 30);
  static const _connectionTimeout = Duration(seconds: 10);
  static const _delayBetweenCommands = Duration(milliseconds: 500);

  void _logDebug(String message) {
    if (kDebugMode) {
      debugPrint('[SSH] $message');
    }
  }

  Future<SSHClient> _createSshClient(DeviceCredentials credentials) async {
    _logDebug('Creating SSH connection to ${credentials.ip}');
    try {
      final socket = await SSHSocket.connect(
        credentials.ip,
        22,
        timeout: _connectionTimeout,
      );
      final client = SSHClient(
        socket,
        username: credentials.username,
        onPasswordRequest: () => credentials.password,
      );
      _logDebug('SSH connection established');
      return client;
    } on TimeoutException {
      _logDebug('Error: SSH connection timed out');
      throw const ServerFailure(
        'Connection timed out. Please check the IP address and port.',
      );
    } on SocketException catch (e) {
      _logDebug('Error: SSH connection failed - ${e.message}');
      throw const ServerFailure(
        'Unable to connect to the device. Check the IP address and port.',
      );
    } catch (e) {
      final errorMsg = e.toString().toLowerCase();
      if (errorMsg.contains('auth')) {
        _logDebug('Error: SSH authentication failed');
        throw const ServerFailure(
          'Authentication failed. Check your username and password.',
        );
      }
      _logDebug('Error: SSH - $e');
      throw ServerFailure('SSH Error: ${e.toString()}');
    }
  }

  Future<String> _executeSshCommand(SSHClient client, String command) async {
    try {
      _logDebug('Executing SSH command: $command');
      final result = await client.run(command).timeout(_commandTimeout);
      final output = utf8.decode(result);
      _logDebug('SSH command executed, output length: ${output.length}');
      return output;
    } catch (e) {
      _logDebug('Error executing SSH command: $e');
      rethrow;
    }
  }

  Future<String> _executeSshCommandsWithShell(
    SSHClient client,
    List<String> commands,
  ) async {
    _logDebug('Starting execution of SSH commands with Shell');
    try {
      final shell = await client.shell(
        pty: SSHPtyConfig(width: 80, height: 24),
      );
      final completer = Completer<String>();
      final output = StringBuffer();
      bool isReady = false;
      int commandIndex = 0;

      void sendNextCommand() {
        if (commandIndex < commands.length) {
          final command = commands[commandIndex];
          _logDebug('Sending SSH Shell command: $command');
          shell.stdin.add(utf8.encode('$command\n'));
          commandIndex++;
        }
      }

      shell.stdout.cast<List<int>>().transform(utf8.decoder).listen((data) {
        output.write(data);
        _logDebug(
          'SSH Shell Output: ${data.replaceAll('\r\n', '\\n').replaceAll('\n', '\\n')}',
        );

        // Wait for the prompt before sending the first command
        if (!isReady && (data.contains('#') || data.contains('>'))) {
          isReady = true;
          sendNextCommand();
        }
        // After a command is sent, wait for the next prompt to send the next command
        else if (isReady && (data.contains('#') || data.contains('>'))) {
          if (commandIndex < commands.length) {
            sendNextCommand();
          } else {
            // All commands sent, close the shell and complete
            shell.close();
            if (!completer.isCompleted) {
              completer.complete(output.toString());
            }
          }
        }
      });
      shell.stderr.cast<List<int>>().transform(utf8.decoder).listen((data) {
        _logDebug('SSH Shell Error: $data');
        output.write(data);
      });
      // General timeout for the whole operation
      Timer(_commandTimeout, () {
        if (!completer.isCompleted) {
          shell.close();
          completer.completeError(
            TimeoutException('SSH Shell operation timed out', _commandTimeout),
          );
        }
      });
      return await completer.future;
    } catch (e) {
      _logDebug('Error in SSH Shell: $e');
      rethrow;
    }
  }

  Future<String> fetchInterfaces(DeviceCredentials credentials) async {
    SSHClient? client;
    try {
      client = await _createSshClient(credentials);
      final result = await _executeSshCommand(
        client,
        'show ip interface brief',
      );
      _logDebug('SSH interfaces fetched');
      return result;
    } catch (e) {
      _logDebug('Error fetching SSH interfaces: $e');
      rethrow;
    } finally {
      client?.close();
    }
  }

  Future<String> fetchDetailedInterfaces(DeviceCredentials credentials) async {
    SSHClient?
    client;
    try {
      client = await _createSshClient(credentials);
      final result = await _executeSshCommand(client, 'show running-config');
      _logDebug('SSH detailed config fetched');
      return result;
    } catch (e) {
      _logDebug('Error fetching SSH detailed config: $e');
      rethrow;
    } finally {
      client?.close();
    }
  }

  Future<String> getRoutingTable(DeviceCredentials credentials) async {
    SSHClient? client;
    try {
      client = await _createSshClient(credentials);
      try {
        final result = await _executeSshCommandsWithShell(client, [
          'terminal length 0',
          'show ip route',
        ]);
        _logDebug('SSH routing table fetched with Shell');
        return result;
      } catch (e) {
        _logDebug('Error in SSH Shell, trying legacy method: $e');
        await _executeSshCommand(client, 'terminal length 0');
        await Future.delayed(_delayBetweenCommands);
        final result = await _executeSshCommand(client, 'show ip route');
        _logDebug('SSH routing table fetched with legacy method');
        return result;
      }
    } catch (e) {
      _logDebug('Error fetching SSH routing table: $e');
      rethrow;
    } finally {
      client?.close();
    }
  }

  Future<String> pingGateway(
    DeviceCredentials credentials,
    String ipAddress,
  ) async {
    _logDebug('Starting SSH ping for IP: $ipAddress');
    SSHClient? client;
    try {
      client = await _createSshClient(credentials);
      final result = await _executeSshCommand(
        client,
        'ping $ipAddress repeat 5',
      );
      _logDebug('SSH ping result received');
      return _analyzePingResult(result);
    } finally {
      client?.close();
    }
  }

  String _analyzePingResult(String output) {
    _logDebug('Analyzing ping result');
    if (output.contains('!!!!!') ||
        output.contains('Success rate is 100') ||
        output.contains('Success rate is 80')) {
      return 'Success! Gateway is reachable.';
    } else if (output.contains('.....') ||
        output.contains('Success rate is 0')) {
      return 'Timeout. Gateway is not reachable.';
    } else if (output.toLowerCase().contains('unknown host')) {
      return 'Error: Unknown host.';
    } else if (output.toLowerCase().contains('network unreachable')) {
      return 'Error: Network unreachable.';
    }

    return 'Ping failed. Check the IP or connection.';
  }

  Future<String> applyEcmpConfig({
    required DeviceCredentials credentials,
    required List<String> gatewaysToAdd,
    required List<String> gatewaysToRemove,
  }) async {
    _logDebug('Applying ECMP config. ToAdd: ${gatewaysToAdd.join(", ")} - ToRemove: ${gatewaysToRemove.join(", ")}');
    SSHClient? client;
    try {
      client = await _createSshClient(credentials);
      final List<String> commands = ['configure terminal'];

      // Generate commands to remove old gateways
      for (final gateway in gatewaysToRemove) {
        if (gateway.trim().isNotEmpty) {
          commands.add('no ip route 0.0.0.0 0.0.0.0 $gateway');
        }
      }

      // Generate commands to add new gateways
      for (final gateway in gatewaysToAdd) {
        if (gateway.trim().isNotEmpty) {
          commands.add('ip route 0.0.0.0 0.0.0.0 $gateway');
        }
      }
      commands.add('end');

      // Do nothing if there are no gateways to add or remove
      if (gatewaysToAdd.isEmpty && gatewaysToRemove.isEmpty) {
        _logDebug('No changes to apply for ECMP config.');
        return 'No ECMP configuration changes were needed.';
      }

      final result = await _executeSshCommandsWithShell(client, commands);
      _logDebug('ECMP config commands executed');

      if (result.toLowerCase().contains('invalid input') ||
          result.toLowerCase().contains('error')) {
        _logDebug('Error applying ECMP config: $result');
        return 'Failed to apply ECMP configuration. Router response: ${result.split('\n').lastWhere((line) => line.contains('%') || line.contains('^'), orElse: () => 'Unknown error')}';
      }

      return 'ECMP configuration applied successfully.';
    } catch (e) {
      _logDebug('Error applying ECMP config: $e');
      return 'An error occurred while applying ECMP configuration: ${e.toString()}';
    } finally {
      client?.close();
    }
  }

    Future<String> applyPbrRule({
    required DeviceCredentials credentials,
    required PbrRule rule,
  }) async {
    _logDebug('Applying PBR rule with SSH: ${rule.ruleName}');
    SSHClient? client;
    try {
      client = await _createSshClient(credentials);
      
      // ساخت دستورات PBR
      final List<String> commands = ['configure terminal'];
      
      // 1. ساخت Access List (با شماره 101 به عنوان مثال)
      // TODO: در آینده میتوان شماره ACL را داینامیک کرد
      final aclCommand = 'access-list 101 permit ${rule.protocol} ${rule.sourceAddress} ${rule.destinationAddress}${rule.destinationPort != 'any' ? ' eq ${rule.destinationPort}' : ''}';
      commands.add(aclCommand);

      // 2. ساخت Route Map
      commands.add('route-map ${rule.ruleName} permit 10');
      commands.add('match ip address 101');
      if (rule.actionType == PbrActionType.nextHop) {
        commands.add('set ip next-hop ${rule.nextHop}');
      } else {
        commands.add('set interface ${rule.egressInterface}');
      }
      commands.add('exit');

      // 3. اعمال Route Map به اینترفیس
      commands.add('interface ${rule.applyToInterface}');
      commands.add('ip policy route-map ${rule.ruleName}');
      commands.add('end');

      final result = await _executeSshCommandsWithShell(client, commands);
      _logDebug('PBR config commands executed');

      if (result.toLowerCase().contains('invalid input') || result.toLowerCase().contains('error')) {
        return 'Failed to apply PBR configuration. Router response: ${result.split('\n').lastWhere((line) => line.contains('%') || line.contains('^'), orElse: () => 'Unknown error')}';
      }

      return 'PBR rule "${rule.ruleName}" applied successfully.';
    } catch (e) {
      return 'An error occurred while applying PBR rule: ${e.toString()}';
    } finally {
      client?.close();
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\datasources\telnet_client_handler.dart ---

// lib/data/datasources/telnet_client_handler.dart
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:ctelnet/ctelnet.dart';

class TelnetClientHandler {
  static const _commandTimeout = Duration(seconds: 30); // Increased timeout
  static const _connectionTimeout = Duration(seconds: 20);

  void _logDebug(String message) {
    if (kDebugMode) {
      debugPrint('[TELNET] $message');
    }
  }

  Future<String> _executeTelnetCommands(
      DeviceCredentials credentials, List<String> commands) async {
    _logDebug('Starting execution of Telnet commands');
    final completer = Completer<String>();
    final outputBuffer = StringBuffer();
    CTelnetClient? client;
    StreamSubscription<Message>? subscription;

    var state = 'login';
    int commandIndex = 0;
    // Prepend 'terminal length 0' to avoid pagination
    final allCommands = ['terminal length 0', ...commands];
    Timer? timeoutTimer;
    // Setup timeout timer for the whole operation
    timeoutTimer = Timer(_commandTimeout, () {
      _logDebug('Telnet operation timed out');
      if (!completer.isCompleted) {
        client?.disconnect();
        completer.completeError(const ServerFailure("Telnet operation timed out."));
      }
    });
    client = CTelnetClient(
      host: credentials.ip,
      port: 23,
      timeout: _connectionTimeout,
      onConnect: () {
        _logDebug('Telnet connection established');
      },
      onDisconnect: () {
        _logDebug('Telnet connection closed');
        timeoutTimer?.cancel();
        if (!completer.isCompleted) {
          completer.complete(outputBuffer.toString());
        }
        subscription?.cancel();
      },
      onError: (error) {
        _logDebug('Telnet error: $error');
        timeoutTimer?.cancel();
        if (!completer.isCompleted) {
          completer.completeError(ServerFailure("Telnet Error: $error"));
        }
        subscription?.cancel();
      },
    );

    void executeNextCommand() {
      if (commandIndex < allCommands.length) {
        final cmd = allCommands[commandIndex];
        _logDebug("Sending Telnet: $cmd");
        client?.send('$cmd\n');
        commandIndex++;
      } else {
        // Short delay before disconnecting to ensure all output is received
        Timer(const Duration(seconds: 1), () {
          if (!completer.isCompleted) {
            client?.disconnect();
          }
        });
      }
    }

    try {
      subscription = (await client.connect())?.listen((data) {
        final receivedText = data.text.trim();
        outputBuffer.write(data.text);
        _logDebug("Telnet Received: ${receivedText.replaceAll('\r\n', ' ')}");

        switch (state) {
          case 'login':
            if (receivedText.toLowerCase().contains('username')) {
              client?.send('${credentials.username}\n');
            } else if (receivedText.toLowerCase().contains('password')) {
              client?.send('${credentials.password}\n');
            } else if (receivedText.endsWith('>')) {
              state = 'enable';
              client?.send('enable\n');
            } else if (receivedText.endsWith('#')) {
              state = 'executing';
              outputBuffer.clear(); // Clear buffer before starting commands
              executeNextCommand();
            }
            break;
          case 'enable':
            if (receivedText.toLowerCase().contains('password')) {
              client?.send('${credentials.enablePassword ?? ''}\n');
            } else if (receivedText.endsWith('#')) {
              state = 'executing';
              outputBuffer.clear(); // Clear buffer before starting commands
              executeNextCommand();
            }
            break;
          case 'executing':
            if (receivedText.endsWith('#')) {
              if (commandIndex < allCommands.length) {
                executeNextCommand();
              } else {
                // Short delay before disconnecting
                Timer(const Duration(seconds: 1), () {
                  if (!completer.isCompleted) {
                    client?.disconnect();
                  }
                });
              }
            }
            break;
        }
      });
    } catch (e) {
      _logDebug('Error on Telnet connect: $e');
      timeoutTimer.cancel();
      if (!completer.isCompleted) {
        completer.completeError(ServerFailure("Telnet connection failed: $e"));
      }
    }

    return completer.future;
  }

  Future<String> _executeTelnetPing(
      DeviceCredentials credentials, String ipAddress) async {
    _logDebug('Starting Telnet ping for IP: $ipAddress');
    final completer = Completer<String>();
    CTelnetClient? client;
    StreamSubscription<Message>? subscription;
    var state = 'login';
    final outputBuffer = StringBuffer();
    bool commandSent = false;
    Timer? timeoutTimer;

    // Setup timeout timer
    timeoutTimer = Timer(_commandTimeout, () {
      _logDebug('Ping operation timed out');
      if (!completer.isCompleted) {
        client?.disconnect();
        completer.complete('Timeout. Gateway is not reachable.');
      }
    });
    client = CTelnetClient(
      host: credentials.ip,
      port: 23,
      timeout: _connectionTimeout,
      onConnect: () => _logDebug('Telnet ping connection established'),
      onDisconnect: () {
        _logDebug('Telnet ping connection closed');
        timeoutTimer?.cancel();
        if (!completer.isCompleted) {
          final output = outputBuffer.toString();
          final result = _analyzePingResult(output);
          completer.complete(result);
        }
        subscription?.cancel();
      },
      onError: (error) {
        _logDebug('Telnet ping error: $error');
        timeoutTimer?.cancel();
        if (!completer.isCompleted) {
          completer.completeError(ServerFailure("Ping error: $error"));
        }
      },
    );
    try {
      subscription = (await client.connect())?.listen((data) {
        final receivedText = data.text;
        outputBuffer.write(receivedText);
        _logDebug("Ping Received: ${receivedText.replaceAll('\r\n', ' ')}");

        // Check for ping results in every message
        if (receivedText.contains('!!!!!') ||
            receivedText.contains('Success rate is 100') ||
            receivedText.contains('Success rate is 80')) {
          if (!completer.isCompleted) {
            timeoutTimer?.cancel();
            completer.complete('Success! Gateway is reachable.');
            client?.disconnect();
            return;
          }
        } else if (receivedText.contains('.....') ||
            receivedText.contains('Success rate is 0')) {
          if (!completer.isCompleted) {
            timeoutTimer?.cancel();
            completer.complete('Timeout. Gateway is not reachable.');
            client?.disconnect();
            return;
          }
        }

        final trimmedText = receivedText.trim();
        switch (state) {
          case 'login':
            if (trimmedText.toLowerCase().contains('username')) {
              client?.send('${credentials.username}\n');
            } else if (trimmedText.toLowerCase().contains('password')) {
              client?.send('${credentials.password}\n');
            } else if (trimmedText.endsWith('>')) {
              state = 'enable';
              client?.send('enable\n');
            } else if (trimmedText.endsWith('#')) {
              state = 'executing';
              if (!commandSent) {
                client?.send('ping $ipAddress repeat 5\n');
                commandSent = true;
              }
            }
            break;
          case 'enable':
            if (trimmedText.toLowerCase().contains('password')) {
              client?.send('${credentials.enablePassword ?? ''}\n');
            } else if (trimmedText.endsWith('#')) {
              state = 'executing';
              if (!commandSent) {
                client?.send('ping $ipAddress repeat 5\n');
                commandSent = true;
              }
            }
            break;
        }
      });
    } catch (e) {
      _logDebug('Error in Telnet ping: $e');
      timeoutTimer.cancel();
      if (!completer.isCompleted) {
        completer.completeError(ServerFailure("Ping connection failed: $e"));
      }
    }

    return completer.future;
  }

  Future<String> fetchDetailedInterfaces(DeviceCredentials credentials) async {
    try {
      final result = await _executeTelnetCommands(credentials, ['show running-config']);
      _logDebug('Telnet detailed config fetched');
      return result;
    } catch (e) {
      _logDebug('Error fetching Telnet detailed config: $e');
      rethrow;
    }
  }

  String _analyzePingResult(String output) {
    _logDebug('Analyzing ping result');
    if (output.contains('!!!!!') ||
        output.contains('Success rate is 100') ||
        output.contains('Success rate is 80')) {
      return 'Success! Gateway is reachable.';
    } else if (output.contains('.....') ||
        output.contains('Success rate is 0')) {
      return 'Timeout. Gateway is not reachable.';
    } else if (output.toLowerCase().contains('unknown host')) {
      return 'Error: Unknown host.';
    } else if (output.toLowerCase().contains('network unreachable')) {
      return 'Error: Network unreachable.';
    }

    return 'Ping failed. Check the IP or connection.';
  }

  Future<String> fetchInterfaces(DeviceCredentials credentials) async {
    try {
      final result = await _executeTelnetCommands(
          credentials, ['show ip interface brief']);
      _logDebug('Telnet interfaces fetched');
      return result;
    } catch (e) {
      _logDebug('Error fetching Telnet interfaces: $e');
      rethrow;
    }
  }

  Future<String> getRoutingTable(DeviceCredentials credentials) async {
    try {
      final result = await _executeTelnetCommands(credentials, ['show ip route']);
      _logDebug('Telnet routing table fetched');
      return result;
    } catch (e) {
      _logDebug('Error fetching Telnet routing table: $e');
      rethrow;
    }
  }

  Future<String> pingGateway(DeviceCredentials credentials, String ipAddress) async {
    return await _executeTelnetPing(credentials, ipAddress);
  }
  
  Future<String> applyEcmpConfig({
    required DeviceCredentials credentials,
    required List<String> gatewaysToAdd,
    required List<String> gatewaysToRemove,
  }) async {
    _logDebug('Applying ECMP config via Telnet. ToAdd: ${gatewaysToAdd.join(", ")} - ToRemove: ${gatewaysToRemove.join(", ")}');
    try {
      // Dynamically build the list of commands
      final List<String> commands = ['configure terminal'];

      // Generate commands to remove old gateways
      for (final gateway in gatewaysToRemove) {
        if (gateway.trim().isNotEmpty) {
          commands.add('no ip route 0.0.0.0 0.0.0.0 $gateway');
        }
      }

      // Generate commands to add new gateways
      for (final gateway in gatewaysToAdd) {
        if (gateway.trim().isNotEmpty) {
          commands.add('ip route 0.0.0.0 0.0.0.0 $gateway');
        }
      }
      commands.add('end');

      // Do nothing if there are no gateways to add or remove
      if (gatewaysToAdd.isEmpty && gatewaysToRemove.isEmpty) {
        _logDebug('No changes to apply for ECMP config via Telnet.');
        return 'No ECMP configuration changes were needed.';
      }

      // _executeTelnetCommands already adds 'terminal length 0'
      final result = await _executeTelnetCommands(credentials, commands);
      _logDebug('ECMP config commands sent via Telnet');

      if (result.toLowerCase().contains('invalid input') || result.toLowerCase().contains('error')) {
        _logDebug('Error applying ECMP config via Telnet: $result');
        return 'Failed to apply ECMP configuration. Router response: ${result.split('\n').lastWhere((line) => line.contains('%') || line.contains('^'), orElse: () => 'Unknown error')}';
      }

      return 'ECMP configuration applied successfully.';
    } catch (e) {
      _logDebug('Error applying ECMP config via Telnet: $e');
      return 'An error occurred while applying ECMP configuration: ${e.toString()}';
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\repositories\device_repository_impl.dart ---

// lib/data/repositories/device_repository_impl.dart
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/data/datasources/remote_datasource.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/pbr_rule.dart';
import 'package:load_balance/domain/entities/router_interface.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';

class DeviceRepositoryImpl implements DeviceRepository {
  final RemoteDataSource remoteDataSource;

  DeviceRepositoryImpl({required this.remoteDataSource});

  @override
  Future<void> checkCredentials(DeviceCredentials credentials) async {
    // For SSH and Telnet, verifying credentials by fetching interfaces is a reliable check.
    if (credentials.type == ConnectionType.ssh ||
        credentials.type == ConnectionType.telnet) {
      try {
        await remoteDataSource.fetchInterfaces(credentials);
      } on ServerFailure catch (e) {
        throw ServerFailure(e.message);
      } catch (e) {
        throw ServerFailure(e.toString());
      }
    } else if (credentials.type == ConnectionType.restApi) {
      return await remoteDataSource.checkRestApiCredentials(credentials);
    }
  }

  @override
  Future<List<RouterInterface>> getInterfaces(
    DeviceCredentials credentials,
  ) async {
    try {
      return await remoteDataSource.fetchInterfaces(credentials);
    } on ServerFailure catch (e) {
      throw ServerFailure(e.message);
    } catch (e) {
      throw ServerFailure(e.toString());
    }
  }

  @override
  Future<String> getRoutingTable(DeviceCredentials credentials) async {
    try {
      return await remoteDataSource.getRoutingTable(credentials);
    } on ServerFailure catch (e) {
      return e.message;
    } catch (e) {
      return e.toString();
    }
  }

  @override
  Future<String> pingGateway({
    required DeviceCredentials credentials,
    required String ipAddress,
  }) async {
    try {
      return await remoteDataSource.pingGateway(credentials, ipAddress);
    } on ServerFailure catch (e) {
      return e.message;
    } catch (e) {
      return e.toString();
    }
  }

  @override
  Future<String> applyEcmpConfig({
    required DeviceCredentials credentials,
    required List<String> gatewaysToAdd,
    required List<String> gatewaysToRemove,
  }) async {
    try {
      // Pass the call with the new parameters to the data source
      return await remoteDataSource.applyEcmpConfig(
        credentials: credentials,
        gatewaysToAdd: gatewaysToAdd,
        gatewaysToRemove: gatewaysToRemove,
      );
    } on ServerFailure catch (e) {
      return e.message;
    } catch (e) {
      return e.toString();
    }
  }

  @override
  Future<String> applyPbrRule({
    required DeviceCredentials credentials,
    required PbrRule rule,
  }) async {
    try {
      return await remoteDataSource.applyPbrRule(
        credentials: credentials,
        rule: rule,
      );
    } on ServerFailure catch (e) {
      return e.message;
    } catch (e) {
      return e.toString();
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\entities\device_credentials.dart ---

// lib/domain/entities/device_credentials.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';

class DeviceCredentials extends Equatable {
  final String ip;
  final String username;
  final String password;
  final String? enablePassword;
  final ConnectionType type;
  final Duration connectionTimeout;
  final Duration commandTimeout;

  const DeviceCredentials({
    required this.ip,
    required this.username,
    required this.password,
    this.enablePassword,
    required this.type,
    this.connectionTimeout = const Duration(seconds: 10),
    this.commandTimeout = const Duration(seconds: 20),
  });

  // Data validation
  bool get isValid {
    if (ip.trim().isEmpty || username.trim().isEmpty || password.trim().isEmpty) {
      return false;
    }
    
    // IP format check
    final ipRegex = RegExp(r'^(\d{1,3}\.){3}\d{1,3}$');
    if (!ipRegex.hasMatch(ip.trim())) {
      return false;
    }
    
    // IP range check
    final parts = ip.trim().split('.');
    for (final part in parts) {
      final num = int.tryParse(part);
      if (num == null || num < 0 || num > 255) {
        return false;
      }
    }
    
    return true;
  }

  String? get validationError {
    if (ip.trim().isEmpty) return 'IP address cannot be empty';
    if (username.trim().isEmpty) return 'Username cannot be empty';
    if (password.trim().isEmpty) return 'Password cannot be empty';
    
    final ipRegex = RegExp(r'^(\d{1,3}\.){3}\d{1,3}$');
    if (!ipRegex.hasMatch(ip.trim())) {
      return 'Invalid IP address format';
    }
    
    final parts = ip.trim().split('.');
    for (final part in parts) {
      final num = int.tryParse(part);
      if (num == null || num < 0 || num > 255) {
        return 'IP address octets must be between 0-255';
      }
    }
    
    return null;
  }

  DeviceCredentials copyWith({
    String? ip,
    String? username,
    String? password,
    String? enablePassword,
    ConnectionType? type,
    Duration? connectionTimeout,
    Duration? commandTimeout,
  }) {
    return DeviceCredentials(
      ip: ip ?? this.ip,
      username: username ?? this.username,
      password: password ?? this.password,
      enablePassword: enablePassword ?? this.enablePassword,
      type: type ?? this.type,
      connectionTimeout: connectionTimeout ?? this.connectionTimeout,
      commandTimeout: commandTimeout ?? this.commandTimeout,
    );
  }

  @override
  List<Object?> get props => [
        ip,
        username,
        password,
        enablePassword,
        type,
        connectionTimeout,
        commandTimeout,
      ];
      
  @override
  String toString() {
    return 'DeviceCredentials(ip: $ip, username: $username, type: $type)';
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\entities\pbr_rule.dart ---

//lib/domain/entities/pbr_rule.dart

import 'package:equatable/equatable.dart';
import 'package:load_balance/presentation/bloc/pbr_rule_form/pbr_rule_form_state.dart';

class PbrRule extends Equatable {
  final String ruleName;
  final String sourceAddress;
  final String destinationAddress;
  final String protocol;
  final String destinationPort;
  final PbrActionType actionType;
  final String nextHop;
  final String egressInterface;
  final String applyToInterface;

  const PbrRule({
    required this.ruleName,
    required this.sourceAddress,
    required this.destinationAddress,
    required this.protocol,
    required this.destinationPort,
    required this.actionType,
    required this.nextHop,
    required this.egressInterface,
    required this.applyToInterface,
  });

  @override
  List<Object?> get props => [
        ruleName,
        sourceAddress,
        destinationAddress,
        protocol,
        destinationPort,
        actionType,
        nextHop,
        egressInterface,
        applyToInterface,
      ];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\entities\router_interface.dart ---

// domain/entities/router_interface.dart
import 'package:equatable/equatable.dart';

class RouterInterface extends Equatable {
  final String name;
  final String ipAddress;
  final String status;

  const RouterInterface({
    required this.name,
    required this.ipAddress,
    required this.status,
  });

  @override
  List<Object?> get props => [name, ipAddress, status];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\repositories\device_repository.dart ---

// lib/domain/repositories/device_repository.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/pbr_rule.dart';
import 'package:load_balance/domain/entities/router_interface.dart';

abstract class DeviceRepository {
  Future<void> checkCredentials(DeviceCredentials credentials);
  Future<List<RouterInterface>> getInterfaces(DeviceCredentials credentials);
  Future<String> getRoutingTable(DeviceCredentials credentials);
  Future<String> pingGateway({
    required DeviceCredentials credentials,
    required String ipAddress,
  });
  
  /// Applies the ECMP configuration to the device.
  ///
  /// Takes a list of gateways to add and a list of gateways to remove.
  Future<String> applyEcmpConfig({
    required DeviceCredentials credentials,
    required List<String> gatewaysToAdd,
    required List<String> gatewaysToRemove,
  });

    Future<String> applyPbrRule({
    required DeviceCredentials credentials,
    required PbrRule rule,
  });
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\apply_ecmp_config.dart ---

// lib/domain/usecases/apply_ecmp_config.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class ApplyEcmpConfig {
  final DeviceRepository repository;

  ApplyEcmpConfig(this.repository);

  /// Executes the use case to apply ECMP configuration.
  Future<String> call({
    required DeviceCredentials credentials,
    required List<String> gatewaysToAdd,
    required List<String> gatewaysToRemove,
  }) async {
    // Pass both lists to the repository's method
    return await repository.applyEcmpConfig(
      credentials: credentials,
      gatewaysToAdd: gatewaysToAdd,
      gatewaysToRemove: gatewaysToRemove,
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\apply_pbr_rule.dart ---

// lib/domain/usecases/apply_pbr_rule.dart

import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/pbr_rule.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class ApplyPbrRule {
  final DeviceRepository repository;

  ApplyPbrRule(this.repository);

  Future<String> call({
    required DeviceCredentials credentials,
    required PbrRule rule,
  }) async {
    return await repository.applyPbrRule(
      credentials: credentials,
      rule: rule,
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\check_credentials.dart ---


// domain/usecases/check_credentials.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class CheckCredentials {
  final DeviceRepository repository;

  CheckCredentials(this.repository);

  Future<void> call(DeviceCredentials credentials) async {
    return await repository.checkCredentials(credentials);
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\get_interfaces.dart ---

// domain/usecases/get_interfaces.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class GetInterfaces {
  final DeviceRepository repository;

  GetInterfaces(this.repository);

  Future<List<RouterInterface>> call(DeviceCredentials credentials) async {
    return await repository.getInterfaces(credentials);
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\get_routing_table.dart ---

// domain/usecases/get_routing_table.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class GetRoutingTable {
  final DeviceRepository repository;

  GetRoutingTable(this.repository);

  Future<String> call(DeviceCredentials credentials) async {
    return await repository.getRoutingTable(credentials);
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\ping_gateway.dart ---

// lib/domain/usecases/ping_gateway.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class PingGateway {
  final DeviceRepository repository;

  PingGateway(this.repository);

  // The call method requires credentials to perform the operation on the device.
  Future<String> call({
    required DeviceCredentials credentials,
    required String ipAddress,
  }) async {
    return await repository.pingGateway(
      credentials: credentials,
      ipAddress: ipAddress,
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\connection\connection_bloc.dart ---

// presentation/bloc/connection/connection_bloc.dart
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/usecases/check_credentials.dart';
import 'connection_event.dart';
import 'connection_state.dart';

class ConnectionBloc extends Bloc<ConnectionEvent, ConnectionState> {
  final CheckCredentials checkCredentials;

  ConnectionBloc({required this.checkCredentials}) : super(ConnectionInitial()) {
    on<CheckCredentialsRequested>(_onCheckCredentials);
  }

  Future<void> _onCheckCredentials(
    CheckCredentialsRequested event,
    Emitter<ConnectionState> emit,
  ) async {
    emit(ConnectionLoading());
    try {
      final credentials = DeviceCredentials(
        ip: event.ip,
        username: event.username,
        password: event.password,
        enablePassword: event.enablePassword,
        type: event.type,
      );
      await checkCredentials(credentials);

      // Pass the credentials object in the success state
      emit(ConnectionSuccess(credentials));
    } on ServerFailure catch (e) {
      emit(ConnectionFailure(e.message));
    } catch (e) {
      emit(ConnectionFailure("An unexpected error occurred: ${e.toString()}"));
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\connection\connection_event.dart ---

// presentation/bloc/connection/connection_event.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';

abstract class ConnectionEvent extends Equatable {
  const ConnectionEvent();

  @override
  List<Object?> get props => [];
}

class CheckCredentialsRequested extends ConnectionEvent {
  final String ip;
  final String username;
  final String password;
  final String? enablePassword;
  final ConnectionType type;

  const CheckCredentialsRequested({
    required this.ip,
    required this.username,
    required this.password,
    this.enablePassword,
    required this.type,
  });

  @override
  List<Object?> get props => [ip, username, password, enablePassword, type];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\connection\connection_state.dart ---

// presentation/bloc/connection/connection_state.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';

abstract class ConnectionState extends Equatable {
  const ConnectionState();

  @override
  List<Object> get props => [];
}

class ConnectionInitial extends ConnectionState {}

class ConnectionLoading extends ConnectionState {}

// Now holds the credentials on success to pass them to the next screen
class ConnectionSuccess extends ConnectionState {
  final DeviceCredentials credentials;
  const ConnectionSuccess(this.credentials);

  @override
  List<Object> get props => [credentials];
}

class ConnectionFailure extends ConnectionState {
  final String error;

  const ConnectionFailure(this.error);

  @override
  List<Object> get props => [error];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\load_balancing\load_balancing_bloc.dart ---

// lib/presentation/bloc/load_balancing/load_balancing_bloc.dart
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/usecases/apply_ecmp_config.dart';
import 'package:load_balance/domain/usecases/get_interfaces.dart';
import 'package:load_balance/domain/usecases/get_routing_table.dart';
import 'package:load_balance/domain/usecases/ping_gateway.dart';
// Import the event file with a prefix to resolve the name conflict
import 'load_balancing_event.dart' as events;
import 'load_balancing_state.dart';

class LoadBalancingBloc extends Bloc<events.LoadBalancingEvent, LoadBalancingState> {
  final GetInterfaces getInterfaces;
  final GetRoutingTable getRoutingTable;
  final PingGateway pingGateway;
  final ApplyEcmpConfig applyEcmpConfig; // This is the Use Case class

  // Manage concurrent ping operations
  final Map<String, Timer> _pingTimers = {};
  LoadBalancingBloc({
    required this.getInterfaces,
    required this.getRoutingTable,
    required this.pingGateway,
    required this.applyEcmpConfig, // Injected dependency
  }) : super(const LoadBalancingState()) {
    on<events.ScreenStarted>(_onScreenStarted);
    on<events.FetchInterfacesRequested>(_onFetchInterfaces);
    on<events.FetchRoutingTableRequested>(_onFetchRoutingTable);
    on<events.PingGatewayRequested>(_onPingGateway);
    on<events.LoadBalancingTypeSelected>(_onLoadBalancingTypeSelected);
    on<events.ApplyEcmpConfig>(_onApplyEcmpConfig);
    on<events.ClearPingResult>(_onClearPingResult);
  }

  @override
  Future<void> close() {
    // Clean up timers
    for (final timer in _pingTimers.values) {
      timer.cancel();
    }
    _pingTimers.clear();
    return super.close();
  }

  void _logDebug(String message) {
    if (kDebugMode) {
      debugPrint('[LoadBalancingBloc] $message');
    }
  }

  /// Helper method to parse gateway IPs from the 'show ip route' command output.
  /// THIS METHOD HAS BEEN CORRECTED AND MADE MORE ROBUST.
  List<String> _parseEcmpGateways(String routingTable) {
    final gateways = <String>{}; // Use a Set to handle duplicates automatically.
    
    // A more robust regex that looks for the 'via' keyword after a default route pattern.
    // This handles variations in spacing and formatting.
    final ecmpRegex = RegExp(r'0\.0\.0\.0/0\s.*via\s+([\d\.]+)');
    final subsequentLineRegex = RegExp(r'^\s*\[\d+/\d+\]\s+via\s+([\d\.]+)');

    final lines = routingTable.split('\n');
    bool inEcmpBlock = false;

    for (final line in lines) {
      if (line.contains('0.0.0.0/0')) {
        final match = ecmpRegex.firstMatch(line);
        if (match != null) {
          gateways.add(match.group(1)!);
          inEcmpBlock = true; // Once we find the first line, we enter the block
          continue; // Move to the next line
        }
      }

      // If we are in an ECMP block, check for subsequent indented lines
      if (inEcmpBlock) {
        final match = subsequentLineRegex.firstMatch(line);
        if (match != null) {
          gateways.add(match.group(1)!);
        } else if (line.trim().isNotEmpty && !line.trim().startsWith('[')) {
          // If the line is not empty and doesn't start with '[', the ECMP block has ended.
          inEcmpBlock = false;
        }
      }
    }

    _logDebug('Parsed ECMP gateways (Corrected): ${gateways.toList()}');
    return gateways.toList();
  }


  void _onScreenStarted(events.ScreenStarted event, Emitter<LoadBalancingState> emit) {
    _logDebug('Screen started - IP: ${event.credentials.ip}');
    emit(state.copyWith(credentials: event.credentials));
    // Fetch both interfaces and routing table when the screen starts.
    add(events.FetchInterfacesRequested());
    add(events.FetchRoutingTableRequested());
  }

  void _onLoadBalancingTypeSelected(
    events.LoadBalancingTypeSelected event,
    Emitter<LoadBalancingState> emit,
  ) {
    _logDebug('Load Balancing type selected: ${event.type}');
    emit(state.copyWith(type: event.type));
  }

  void _onClearPingResult(
    events.ClearPingResult event,
    Emitter<LoadBalancingState> emit,
  ) {
    final newPingResults = Map<String, String>.from(state.pingResults);
    newPingResults.remove(event.ipAddress);
    emit(state.copyWith(pingResults: newPingResults));
  }

  Future<void> _onFetchInterfaces(
    events.FetchInterfacesRequested event,
    Emitter<LoadBalancingState> emit,
  ) async {
    if (state.credentials == null) {
      _logDebug('Error: Credentials not available');
      return;
    }

    _logDebug('Starting to fetch interfaces');
    emit(state.copyWith(interfacesStatus: DataStatus.loading));
    try {
      final interfaces = await getInterfaces(state.credentials!);
      _logDebug('${interfaces.length} interfaces received');
      emit(state.copyWith(
        interfaces: interfaces,
        interfacesStatus: DataStatus.success,
      ));
    } on ServerFailure catch (e) {
      _logDebug('Error fetching interfaces: ${e.message}');
      emit(state.copyWith(
        interfacesStatus: DataStatus.failure,
        error: e.message,
      ));
    } catch (e) {
      _logDebug('Unknown error fetching interfaces: $e');
      emit(state.copyWith(
        interfacesStatus: DataStatus.failure,
        error: 'An unknown error occurred while fetching interfaces.',
      ));
    }
  }

  Future<void> _onFetchRoutingTable(
    events.FetchRoutingTableRequested event,
    Emitter<LoadBalancingState> emit,
  ) async {
    if (state.credentials == null) {
      _logDebug('Error: Credentials not available');
      return;
    }

    _logDebug('Starting to fetch routing table');
    emit(state.copyWith(
      routingTableStatus: DataStatus.loading,
      clearRoutingTable: true,
    ));
    try {
      final table = await getRoutingTable(state.credentials!);
      // After fetching the table, parse it to find existing gateways.
      final gateways = _parseEcmpGateways(table);
      _logDebug('Routing table received, ${gateways.length} ECMP gateways found.');
      
      // Emit the new state with both the raw table and the parsed gateways.
      emit(state.copyWith(
        routingTable: table,
        routingTableStatus: DataStatus.success,
        initialEcmpGateways: gateways,
      ));
    } on ServerFailure catch (e) {
      _logDebug('Error fetching routing table: ${e.message}');
      emit(state.copyWith(
        routingTable: 'Error: ${e.message}',
        routingTableStatus: DataStatus.failure,
      ));
    } catch (e) {
      _logDebug('Unknown error fetching routing table: $e');
      emit(state.copyWith(
        routingTable: 'An unknown error occurred while fetching routing table.',
        routingTableStatus: DataStatus.failure,
      ));
    }
  }

  Future<void> _onPingGateway(
    events.PingGatewayRequested event,
    Emitter<LoadBalancingState> emit,
  ) async {
    if (state.credentials == null) {
      _logDebug('Error: Credentials not available');
      return;
    }

    final ipAddress = event.ipAddress.trim();
    
    // IP Validation
    if (ipAddress.isEmpty) {
      _logDebug('Error: Empty IP for ping');
      final newPingResults = Map<String, String>.from(state.pingResults);
      newPingResults[''] = 'Error: IP address cannot be empty.';
      emit(state.copyWith(pingResults: newPingResults));
      return;
    }

    // Check if ping is already in progress
    if (state.pingingIp == ipAddress) {
      _logDebug('Ping for IP $ipAddress is already in progress');
      return;
    }

    // Cancel previous timer if it exists
    _pingTimers[ipAddress]?.cancel();
    _logDebug('Starting ping for IP: $ipAddress');
    emit(state.copyWith(
      pingStatus: DataStatus.loading,
      pingingIp: ipAddress,
    ));
    try {
      final result = await pingGateway(
        credentials: state.credentials!,
        ipAddress: ipAddress,
      );
      _logDebug('Ping result for $ipAddress: $result');
      
      _pingTimers[ipAddress]?.cancel();
      _pingTimers.remove(ipAddress);
      
      final newPingResults = Map<String, String>.from(state.pingResults);
      newPingResults[ipAddress] = result;
      emit(state.copyWith(
        pingResults: newPingResults,
        pingStatus: DataStatus.success,
        pingingIp: '',
      ));
    } catch (e) {
      _logDebug('Error during ping for $ipAddress: $e');
      _pingTimers[ipAddress]?.cancel();
      _pingTimers.remove(ipAddress);
      final newPingResults = Map<String, String>.from(state.pingResults);
      newPingResults[ipAddress] = 'Ping Error: ${e.toString()}';
      emit(state.copyWith(
        pingResults: newPingResults,
        pingStatus: DataStatus.failure,
        pingingIp: '',
      ));
    }
  }

  Future<void> _onApplyEcmpConfig(
    events.ApplyEcmpConfig event,
    Emitter<LoadBalancingState> emit,
  ) async {
    if (state.credentials == null) {
      _logDebug('Error: Credentials not available for applying config');
      return;
    }

    _logDebug('Starting to apply ECMP config');
    
    // Get the initial list from the state and the final list from the UI event.
    final initialGateways = state.initialEcmpGateways;
    final finalGateways = event.finalGateways;
    _logDebug('Initial Gateways: $initialGateways');
    _logDebug('Final Gateways: $finalGateways');

    // The smart diff logic to determine what to add and what to remove.
    final gatewaysToAdd = finalGateways.where((g) => !initialGateways.contains(g)).toList();
    final gatewaysToRemove = initialGateways.where((g) => !finalGateways.contains(g)).toList();

    _logDebug('Gateways to Add: $gatewaysToAdd');
    _logDebug('Gateways to Remove: $gatewaysToRemove');

    emit(state.copyWith(status: DataStatus.loading, clearSuccessMessage: true));
    try {
      final result = await applyEcmpConfig(
        credentials: state.credentials!,
        gatewaysToAdd: gatewaysToAdd,
      gatewaysToRemove: gatewaysToRemove,
      );
      _logDebug('ECMP config apply result: $result');
      
      if (result.toLowerCase().contains('fail') || result.toLowerCase().contains('error')) {
         emit(state.copyWith(
            status: DataStatus.failure,
            error: result,
          ));
      } else {
         emit(state.copyWith(
            status: DataStatus.success,
            successMessage: result,
          ));
         // After a successful operation, refresh the routing table to reflect the new state in the UI.
         add(events.FetchRoutingTableRequested());
      }
    } catch (e) {
      _logDebug('Error applying ECMP config: $e');
      emit(state.copyWith(
        status: DataStatus.failure,
        error: 'Failed to apply config: ${e.toString()}',
      ));
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\load_balancing\load_balancing_event.dart ---

// lib/presentation/bloc/load_balancing/load_balancing_event.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart';

abstract class LoadBalancingEvent extends Equatable {
  const LoadBalancingEvent();
  @override
  List<Object?> get props => [];
}

class ScreenStarted extends LoadBalancingEvent {
  final DeviceCredentials credentials;
  const ScreenStarted(this.credentials);
  @override
  List<Object?> get props => [credentials];
}

class LoadBalancingTypeSelected extends LoadBalancingEvent {
  final LoadBalancingType type;
  const LoadBalancingTypeSelected(this.type);
  @override
  List<Object> get props => [type];
}

class FetchInterfacesRequested extends LoadBalancingEvent {}

class FetchRoutingTableRequested extends LoadBalancingEvent {}

class PingGatewayRequested extends LoadBalancingEvent {
  final String ipAddress;
  const PingGatewayRequested(this.ipAddress);
  @override
  List<Object?> get props => [ipAddress];
}

class ClearPingResult extends LoadBalancingEvent {
  final String ipAddress;
  const ClearPingResult(this.ipAddress);
  @override
  List<Object?> get props => [ipAddress];
}

class ApplyEcmpConfig extends LoadBalancingEvent {
  // Renamed for clarity: this is the final list of gateways from the UI.
  final List<String> finalGateways; 
  const ApplyEcmpConfig({required this.finalGateways});
  @override
  List<Object> get props => [finalGateways];
}

class ApplyPbrConfig extends LoadBalancingEvent {
  final String sourceNetwork;
  final String gateway;
  const ApplyPbrConfig({required this.sourceNetwork, required this.gateway});
  @override
  List<Object> get props => [sourceNetwork, gateway];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\load_balancing\load_balancing_state.dart ---

// lib/presentation/bloc/load_balancing/load_balancing_state.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';

enum LoadBalancingType { ecmp, pbr }
enum DataStatus { initial, loading, success, failure }

class LoadBalancingState extends Equatable {
  // Holds the credentials to be used for each request
  final DeviceCredentials? credentials;
  final LoadBalancingType type;
  // General status for operations like applying configs
  final DataStatus status;
  final String error;
  // Specific message for successful operations
  final String? successMessage;

  final List<RouterInterface> interfaces;
  final DataStatus interfacesStatus;

  // This new property holds the list of ECMP gateways read from the router.
  final List<String> initialEcmpGateways;

  final String? routingTable;
  final DataStatus routingTableStatus;

  final Map<String, String> pingResults;
  final DataStatus pingStatus;
  final String? pingingIp;

  const LoadBalancingState({
    this.credentials,
    this.type = LoadBalancingType.ecmp,
    this.status = DataStatus.initial,
    this.error = '',
    this.successMessage,
    this.interfaces = const [],
    this.interfacesStatus = DataStatus.initial,
    this.initialEcmpGateways = const [], // Initialize as empty list
    this.routingTable,
    this.routingTableStatus = DataStatus.initial,
    this.pingResults = const {},
    this.pingStatus = DataStatus.initial,
    this.pingingIp,
  });

  LoadBalancingState copyWith({
    DeviceCredentials? credentials,
    LoadBalancingType? type,
    DataStatus? status,
    String? error,
    String? successMessage,
    bool clearSuccessMessage = false,
    List<RouterInterface>? interfaces,
    DataStatus? interfacesStatus,
    List<String>? initialEcmpGateways, // Add to copyWith
    String? routingTable,
    bool clearRoutingTable = false,
    DataStatus? routingTableStatus,
    Map<String, String>? pingResults,
    DataStatus? pingStatus,
    String? pingingIp,
  }) {
    return LoadBalancingState(
      credentials: credentials ?? this.credentials,
      type: type ?? this.type,
      status: status ?? this.status,
      // Clear error on new status, unless it's a failure status
      error: (status != null && status != DataStatus.failure) ? '' : error ?? this.error,
      // Handle clearing or setting the success message
      successMessage: clearSuccessMessage ? null : successMessage ?? this.successMessage,
      interfaces: interfaces ?? this.interfaces,
      interfacesStatus: interfacesStatus ?? this.interfacesStatus,
      initialEcmpGateways: initialEcmpGateways ?? this.initialEcmpGateways, // Add to copyWith
      routingTable: clearRoutingTable ? null : routingTable ?? this.routingTable,
      routingTableStatus: routingTableStatus ?? this.routingTableStatus,
      pingResults: pingResults ?? this.pingResults,
      pingStatus: pingStatus ?? this.pingStatus,
      pingingIp: pingingIp ?? this.pingingIp,
    );
  }

  @override
  List<Object?> get props => [
        credentials, type, status, error, successMessage, interfaces, interfacesStatus,
        initialEcmpGateways, // Add to props for Equatable
        routingTable, routingTableStatus, pingResults, pingStatus, pingingIp
      ];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\pbr_rule_form\pbr_rule_form_bloc.dart ---

import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/pbr_rule.dart';
import 'package:load_balance/domain/usecases/apply_pbr_rule.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart';
import 'pbr_rule_form_event.dart';
import 'pbr_rule_form_state.dart';

class PbrRuleFormBloc extends Bloc<PbrRuleFormEvent, PbrRuleFormState> {
  final ApplyPbrRule applyPbrRule; 
  final DeviceCredentials credentials; 
  PbrRuleFormBloc({required this.applyPbrRule, required this.credentials}) : super(const PbrRuleFormState()) {
    on<FormLoaded>(_onFormLoaded);
    on<RuleNameChanged>((event, emit) => emit(state.copyWith(ruleName: event.value)));
    on<SourceAddressChanged>((event, emit) => emit(state.copyWith(sourceAddress: event.value)));
    on<DestinationAddressChanged>((event, emit) => emit(state.copyWith(destinationAddress: event.value)));
    on<ProtocolChanged>((event, emit) => emit(state.copyWith(protocol: event.value)));
    on<DestinationPortChanged>((event, emit) => emit(state.copyWith(destinationPort: event.value)));
    on<ActionTypeChanged>((event, emit) => emit(state.copyWith(actionType: event.value)));
    on<NextHopChanged>((event, emit) => emit(state.copyWith(nextHop: event.value)));
    on<EgressInterfaceChanged>((event, emit) => emit(state.copyWith(egressInterface: event.value)));
    on<ApplyToInterfaceChanged>((event, emit) => emit(state.copyWith(applyToInterface: event.value)));
    on<FormSubmitted>(_onFormSubmitted);
    
  }

  /// This handler is now much simpler. It just takes the pre-fetched list
  /// of interfaces and populates the state. No network call is made.
  void _onFormLoaded(FormLoaded event, Emitter<PbrRuleFormState> emit) {
    // In edit mode, we would also load the existing rule data here.
    // For now, we just populate the dropdowns.
    emit(state.copyWith(
      formStatus: DataStatus.success,
      availableInterfaces: event.interfaces,
      // Set initial values for the dropdowns with the first available interface.
      egressInterface: event.interfaces.isNotEmpty ? event.interfaces.first.name : '',
      applyToInterface: event.interfaces.isNotEmpty ? event.interfaces.first.name : '',
    ));
  }

  Future<void> _onFormSubmitted(FormSubmitted event, Emitter<PbrRuleFormState> emit) async {
    emit(state.copyWith(formStatus: DataStatus.loading));

    // TODO: اعتبارسنجی کامل فیلدها
    if (state.ruleName.isEmpty) {
      emit(state.copyWith(formStatus: DataStatus.failure, errorMessage: 'Rule Name cannot be empty.'));
      return;
    }

    final newRule = PbrRule(
      ruleName: state.ruleName,
      sourceAddress: state.sourceAddress,
      destinationAddress: state.destinationAddress,
      protocol: state.protocol,
      destinationPort: state.destinationPort,
      actionType: state.actionType,
      nextHop: state.nextHop,
      egressInterface: state.egressInterface,
      applyToInterface: state.applyToInterface,
    );

    try {
      final result = await applyPbrRule(credentials: credentials, rule: newRule);
      emit(state.copyWith(formStatus: DataStatus.success, successMessage: result));
    } catch (e) {
      emit(state.copyWith(formStatus: DataStatus.failure, errorMessage: e.toString()));
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\pbr_rule_form\pbr_rule_form_event.dart ---

import 'package:equatable/equatable.dart';
import 'package:load_balance/domain/entities/router_interface.dart';
import 'package:load_balance/presentation/bloc/pbr_rule_form/pbr_rule_form_state.dart';

abstract class PbrRuleFormEvent extends Equatable {
  const PbrRuleFormEvent();
  @override
  List<Object?> get props => [];
}

/// This event is dispatched when the form opens to pass the initial data.
class FormLoaded extends PbrRuleFormEvent {
  final List<RouterInterface> interfaces; // Changed from DeviceCredentials
  final String? ruleId; // For edit mode

  const FormLoaded({required this.interfaces, this.ruleId});

  @override
  List<Object?> get props => [interfaces, ruleId];
}

/// Events for when each form field changes.
class RuleNameChanged extends PbrRuleFormEvent {
  final String value;
  const RuleNameChanged(this.value);
  @override
  List<Object?> get props => [value];
}

class SourceAddressChanged extends PbrRuleFormEvent {
  final String value;
  const SourceAddressChanged(this.value);
  @override
  List<Object?> get props => [value];
}

class DestinationAddressChanged extends PbrRuleFormEvent {
  final String value;
  const DestinationAddressChanged(this.value);
  @override
  List<Object?> get props => [value];
}

class ProtocolChanged extends PbrRuleFormEvent {
  final String value;
  const ProtocolChanged(this.value);
  @override
  List<Object?> get props => [value];
}

class DestinationPortChanged extends PbrRuleFormEvent {
  final String value;
  const DestinationPortChanged(this.value);
  @override
  List<Object?> get props => [value];
}

class ActionTypeChanged extends PbrRuleFormEvent {
  final PbrActionType value;
  const ActionTypeChanged(this.value);
  @override
  List<Object?> get props => [value];
}

class NextHopChanged extends PbrRuleFormEvent {
  final String value;
  const NextHopChanged(this.value);
  @override
  List<Object?> get props => [value];
}

class EgressInterfaceChanged extends PbrRuleFormEvent {
  final String value;
  const EgressInterfaceChanged(this.value);
  @override
  List<Object?> get props => [value];
}

class ApplyToInterfaceChanged extends PbrRuleFormEvent {
  final String value;
  const ApplyToInterfaceChanged(this.value);
  @override
  List<Object?> get props => [value];
}

/// Event for when the user presses the 'SAVE' button.
class FormSubmitted extends PbrRuleFormEvent {}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\pbr_rule_form\pbr_rule_form_state.dart ---

import 'package:equatable/equatable.dart';
import 'package:load_balance/domain/entities/router_interface.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart'; // for DataStatus

enum PbrActionType { nextHop, interface }

class PbrRuleFormState extends Equatable {
  // Overall form status
  final DataStatus formStatus;

  // List of interfaces to populate dropdowns
  final List<RouterInterface> availableInterfaces;

  // -- Form field values --
  final String ruleName;
  final String sourceAddress;
  final String destinationAddress;
  final String protocol;
  final String destinationPort;
  
  final PbrActionType actionType;
  final String nextHop;
  final String egressInterface;

  final String applyToInterface;
  
  final String? errorMessage;
  final String? successMessage;

  const PbrRuleFormState({
    this.formStatus = DataStatus.initial,
    this.availableInterfaces = const [],
    this.ruleName = '',
    this.sourceAddress = 'any',
    this.destinationAddress = 'any',
    this.protocol = 'any',
    this.destinationPort = 'any',
    this.actionType = PbrActionType.nextHop,
    this.nextHop = '',
    this.egressInterface = '',
    this.applyToInterface = '',
    this.errorMessage,
    this.successMessage,
  });

  PbrRuleFormState copyWith({
    DataStatus? formStatus,
    List<RouterInterface>? availableInterfaces,
    String? ruleName,
    String? sourceAddress,
    String? destinationAddress,
    String? protocol,
    String? destinationPort,
    PbrActionType? actionType,
    String? nextHop,
    String? egressInterface,
    String? applyToInterface,
    String? errorMessage,
    String? successMessage,
  }) {
    return PbrRuleFormState(
      formStatus: formStatus ?? this.formStatus,
      availableInterfaces: availableInterfaces ?? this.availableInterfaces,
      ruleName: ruleName ?? this.ruleName,
      sourceAddress: sourceAddress ?? this.sourceAddress,
      destinationAddress: destinationAddress ?? this.destinationAddress,
      protocol: protocol ?? this.protocol,
      destinationPort: destinationPort ?? this.destinationPort,
      actionType: actionType ?? this.actionType,
      nextHop: nextHop ?? this.nextHop,
      egressInterface: egressInterface ?? this.egressInterface,
      applyToInterface: applyToInterface ?? this.applyToInterface,
      errorMessage: errorMessage ?? this.errorMessage,
      successMessage: successMessage ?? this.successMessage,
    );
  }

  @override
  List<Object?> get props => [
        formStatus,
        availableInterfaces,
        ruleName,
        sourceAddress,
        destinationAddress,
        protocol,
        destinationPort,
        actionType,
        nextHop,
        egressInterface,
        applyToInterface,
        errorMessage,
        successMessage,
      ];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\connection\connection_screen.dart ---

// presentation/screens/connection/connection_screen.dart
import 'package:flutter/material.dart' hide ConnectionState;
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:load_balance/presentation/bloc/connection/connection_bloc.dart';
import 'package:load_balance/presentation/bloc/connection/connection_event.dart';
import 'package:load_balance/presentation/bloc/connection/connection_state.dart';

enum ConnectionType { ssh, telnet, restApi }

class ConnectionScreen extends StatefulWidget {
  const ConnectionScreen({super.key});

  @override
  State<ConnectionScreen> createState() => _ConnectionScreenState();
}

class _ConnectionScreenState extends State<ConnectionScreen> {
  final _formKey = GlobalKey<FormState>();
  final _ipController = TextEditingController();
  final _usernameController = TextEditingController();
  final _passwordController = TextEditingController();
  final _enablePasswordController = TextEditingController();
  bool _isPasswordVisible = false;
  bool _isEnablePasswordVisible = false;

  ConnectionType _selectedType = ConnectionType.ssh;

  @override
  void dispose() {
    _ipController.dispose();
    _usernameController.dispose();
    _passwordController.dispose();
    _enablePasswordController.dispose();
    super.dispose();
  }

  void _checkCredentials() {
    if (_formKey.currentState!.validate()) {
      context.read<ConnectionBloc>().add(
            CheckCredentialsRequested(
              ip: _ipController.text,
              username: _usernameController.text,
              password: _passwordController.text,
              enablePassword: _enablePasswordController.text,
              type: _selectedType,
            ),
          );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Router Connection'),
      ),
      body: BlocListener<ConnectionBloc, ConnectionState>(
        listener: (context, state) {
          if (state is ConnectionSuccess) {
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(
                const SnackBar(
                  content: Text('Connection Successful!'),
                  backgroundColor: Colors.green,
                ),
              );
            // Navigate and pass credentials to the next screen
            context.go('/config', extra: state.credentials);
          } else if (state is ConnectionFailure) {
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(
                SnackBar(
                  content: Text('Error: ${state.error}'),
                  backgroundColor: Colors.red,
                ),
              );
          }
        },
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24.0),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(
                    'Enter Router Credentials',
                    style: Theme.of(context).textTheme.headlineSmall,
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 32),
                  TextFormField(
                    controller: _ipController,
                    decoration: const InputDecoration(
                      labelText: 'IP Address',
                      prefixIcon: Icon(Icons.router),
                    ),
                    keyboardType: TextInputType.number,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please enter an IP address';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _usernameController,
                    decoration: const InputDecoration(
                      labelText: 'Username',
                      prefixIcon: Icon(Icons.person),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please enter a username';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _passwordController,
                    obscureText: !_isPasswordVisible,
                    decoration: InputDecoration(
                      labelText: 'Password',
                      prefixIcon: const Icon(Icons.lock_outline),
                      suffixIcon: IconButton(
                        icon: Icon(_isPasswordVisible
                            ? Icons.visibility_off
                            : Icons.visibility),
                        onPressed: () => setState(
                            () => _isPasswordVisible = !_isPasswordVisible),
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please enter a password';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  Visibility(
                    visible: _selectedType != ConnectionType.restApi,
                    child: TextFormField(
                      controller: _enablePasswordController,
                      obscureText: !_isEnablePasswordVisible,
                      decoration: InputDecoration(
                        labelText: 'Enable Password (optional)',
                        prefixIcon: const Icon(Icons.lock),
                        suffixIcon: IconButton(
                          icon: Icon(_isEnablePasswordVisible
                              ? Icons.visibility_off
                              : Icons.visibility),
                          onPressed: () => setState(() =>
                              _isEnablePasswordVisible =
                                  !_isEnablePasswordVisible),
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 24),
                  SegmentedButton<ConnectionType>(
                    segments: const <ButtonSegment<ConnectionType>>[
                      ButtonSegment<ConnectionType>(
                          value: ConnectionType.ssh,
                          label: Text('SSHv2'),
                          icon: Icon(Icons.security)),
                      ButtonSegment<ConnectionType>(
                          value: ConnectionType.telnet,
                          label: Text('Telnet'),
                          icon: Icon(Icons.lan)),
                      ButtonSegment<ConnectionType>(
                          value: ConnectionType.restApi,
                          label: Text('REST API'),
                          icon: Icon(Icons.http)),
                    ],
                    selected: {_selectedType},
                    onSelectionChanged: (Set<ConnectionType> newSelection) {
                      setState(() {
                        _selectedType = newSelection.first;
                      });
                    },
                  ),
                  const SizedBox(height: 32),
                  BlocBuilder<ConnectionBloc, ConnectionState>(
                    builder: (context, state) {
                      if (state is ConnectionLoading) {
                        return const Center(child: CircularProgressIndicator());
                      }
                      return ElevatedButton.icon(
                        icon: const Icon(Icons.login),
                        label: const Text('Check Credentials'),
                        onPressed: _checkCredentials,
                        style: ElevatedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          textStyle: const TextStyle(fontSize: 16),
                        ),
                      );
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\load_balancing\add_edit_pbr_rule_screen.dart ---

import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';
import 'package:load_balance/domain/usecases/apply_pbr_rule.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_bloc.dart';
import 'package:load_balance/presentation/bloc/pbr_rule_form/pbr_rule_form_bloc.dart';
import 'package:load_balance/presentation/bloc/pbr_rule_form/pbr_rule_form_event.dart';
import 'package:load_balance/presentation/bloc/pbr_rule_form/pbr_rule_form_state.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart' show DataStatus;
import 'widgets/pbr_rule_form_sections.dart';

class AddEditPbrRuleScreen extends StatelessWidget {
  final DeviceCredentials? credentials;
  final String? ruleId;

  const AddEditPbrRuleScreen({
    super.key,
    this.credentials,
    this.ruleId,
  });

  @override
  Widget build(BuildContext context) {
    // 1. لیست اینترفیس‌ها را از بلاک اصلی (که از قبل داده‌ها را دارد) می‌خوانیم
    final existingInterfaces = context.read<LoadBalancingBloc>().state.interfaces;

    return BlocProvider(
      create: (context) {
        // 2. بلاک جدید فرم را با وابستگی‌ها و داده‌های اولیه ایجاد می‌کنیم
        final repository = context.read<DeviceRepository>();
        return PbrRuleFormBloc(
          applyPbrRule: ApplyPbrRule(repository),
          credentials: credentials!,
        )..add(FormLoaded(
            interfaces: existingInterfaces,
            ruleId: ruleId,
          ));
      },
      child: BlocListener<PbrRuleFormBloc, PbrRuleFormState>(
        // 3. به نتیجه ثبت فرم گوش می‌دهیم تا عملیات مناسب را انجام دهیم
        listenWhen: (prev, curr) => prev.formStatus != curr.formStatus,
        listener: (context, state) {
          if (state.formStatus == DataStatus.success && state.successMessage != null) {
            // نمایش پیام موفقیت
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(SnackBar(
                content: Text(state.successMessage!),
                backgroundColor: Colors.green,
              ));
            // بازگشت به صفحه قبل
            Navigator.of(context).pop();
          } else if (state.formStatus == DataStatus.failure && state.errorMessage != null) {
            // نمایش پیام خطا
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(SnackBar(
                content: Text(state.errorMessage!),
                backgroundColor: Colors.red,
              ));
          }
        },
        child: Scaffold(
          appBar: AppBar(
            title: Text(ruleId != null ? 'Edit: $ruleId' : 'Add New PBR Rule'),
            actions: [
              // 4. دکمه SAVE به state گوش می‌دهد و رویداد ثبت را ارسال می‌کند
              BlocBuilder<PbrRuleFormBloc, PbrRuleFormState>(
                buildWhen: (p, c) => p.formStatus != c.formStatus,
                builder: (context, state) {
                  // اگر در حال ارسال بود، یک لودینگ نمایش بده
                  if (state.formStatus == DataStatus.loading) {
                    return const Padding(
                      padding: EdgeInsets.all(16.0),
                      child: SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
                      ),
                    );
                  }
                  // در غیر این صورت دکمه را نمایش بده
                  return TextButton(
                    onPressed: () {
                      context.read<PbrRuleFormBloc>().add(FormSubmitted());
                    },
                    child: const Text('SAVE'),
                  );
                },
              ),
            ],
          ),
          body: SingleChildScrollView(
            padding: const EdgeInsets.all(16.0),
            child: Form(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: const [
                  TrafficMatchCard(),
                  SizedBox(height: 16),
                  RoutingActionCard(),
                  SizedBox(height: 16),
                  ApplyInterfaceCard(),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\load_balancing\load_balancing_screen.dart ---

// lib/presentation/screens/load_balancing/load_balancing_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_event.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart';
import 'package:load_balance/presentation/screens/load_balancing/widgets/ecmp_form.dart';
import 'package:load_balance/presentation/screens/load_balancing/widgets/pbr_form.dart';

class LoadBalancingScreen extends StatefulWidget {
  final DeviceCredentials credentials;
  const LoadBalancingScreen({super.key, required this.credentials});

  @override
  State<LoadBalancingScreen> createState() => _LoadBalancingScreenState();
}

class _LoadBalancingScreenState extends State<LoadBalancingScreen> {
  @override
  void initState() {
    super.initState();
    // Start the process by passing credentials to the BLoC.
    context.read<LoadBalancingBloc>().add(ScreenStarted(widget.credentials));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Load Balancing Configuration')),
      // دکمه شناور به اینجا منتقل شد
      floatingActionButton: BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
        buildWhen: (prev, curr) => prev.type != curr.type,
        builder: (context, state) {
          // دکمه فقط زمانی نمایش داده میشود که تب PBR فعال باشد
          if (state.type == LoadBalancingType.pbr) {
            return FloatingActionButton.extended(
              onPressed: () {
                final credentials = context
                    .read<LoadBalancingBloc>()
                    .state
                    .credentials;
                if (credentials != null) {
                  context.goNamed('add_pbr_rule', extra: credentials);
                }
              },
              label: const Text('Add New Rule'),
              icon: const Icon(Icons.add),
            );
          }
          // در غیر این صورت، چیزی نمایش داده نمیشود
          return const SizedBox.shrink();
        },
      ),
      body: BlocListener<LoadBalancingBloc, LoadBalancingState>(
        // Listen for general status changes (e.g., after applying config)
        listenWhen: (previous, current) => previous.status != current.status,
        listener: (context, state) {
          if (state.status == DataStatus.success &&
              state.successMessage != null) {
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(
                SnackBar(
                  content: Text(state.successMessage!),
                  backgroundColor: Colors.green,
                ),
              );
          } else if (state.status == DataStatus.failure &&
              state.error.isNotEmpty) {
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(
                SnackBar(
                  content: Text('Error: ${state.error}'),
                  backgroundColor: Colors.red,
                ),
              );
          }
        },
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Text(
                'Select Load Balancing Method',
                style: Theme.of(context).textTheme.titleLarge,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),
              BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
                builder: (context, state) {
                  return SegmentedButton<LoadBalancingType>(
                    segments: const <ButtonSegment<LoadBalancingType>>[
                      ButtonSegment<LoadBalancingType>(
                        value: LoadBalancingType.ecmp,
                        label: Text('ECMP'),
                        icon: Icon(Icons.alt_route),
                      ),
                      ButtonSegment<LoadBalancingType>(
                        value: LoadBalancingType.pbr,
                        label: Text('PBR'),
                        icon: Icon(Icons.rule),
                      ),
                    ],
                    selected: {state.type},
                    onSelectionChanged: (Set<LoadBalancingType> newSelection) {
                      context.read<LoadBalancingBloc>().add(
                        LoadBalancingTypeSelected(newSelection.first),
                      );
                    },
                  );
                },
              ),
              const SizedBox(height: 24),
              const _RouterInfoSection(), // Widget for smart features
              const SizedBox(height: 24),
              BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
                builder: (context, state) {
                  if (state.type == LoadBalancingType.ecmp) {
                    return const EcmpForm();
                  } else {
                    return const PbrForm();
                  }
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// A private widget to display router info (Interfaces and Routing Table)
class _RouterInfoSection extends StatelessWidget {
  const _RouterInfoSection();
  @override
  Widget build(BuildContext context) {
    final state = context.watch<LoadBalancingBloc>().state;
    return Card(
      clipBehavior: Clip.antiAlias,
      child: ExpansionTile(
        initiallyExpanded: true,
        title: const Text('Router Information'),
        subtitle: const Text('View interfaces and routing table'),
        children: [
          _buildInterfacesInfo(context, state),
          const Divider(height: 1),
          _buildRoutingTableInfo(context, state),
        ],
      ),
    );
  }

  Widget _buildInterfacesInfo(BuildContext context, LoadBalancingState state) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Text(
              'Device Interfaces',
              style: Theme.of(context).textTheme.titleMedium,
            ),
          ),
          const SizedBox(height: 8),
          if (state.interfacesStatus == DataStatus.loading)
            const Center(child: CircularProgressIndicator())
          else if (state.interfacesStatus == DataStatus.failure)
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Text(
                'Error fetching interfaces: ${state.error}',
                style: const TextStyle(color: Colors.red),
              ),
            )
          else if (state.interfaces.isEmpty)
            const Padding(
              padding: EdgeInsets.symmetric(horizontal: 16.0),
              child: Text('No active interfaces found or connection failed.'),
            )
          else
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: DataTable(
                columns: const [
                  DataColumn(label: Text('Interface')),
                  DataColumn(label: Text('IP Address')),
                  DataColumn(label: Text('Status')),
                ],
                rows: state.interfaces
                    .map(
                      (iface) => DataRow(
                        cells: [
                          DataCell(Text(iface.name)),
                          DataCell(Text(iface.ipAddress)),
                          DataCell(
                            Text(
                              iface.status,
                              style: TextStyle(
                                color: iface.status == 'up'
                                    ? Colors.green
                                    : Colors.orange,
                              ),
                            ),
                          ),
                        ],
                      ),
                    )
                    .toList(),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildRoutingTableInfo(
    BuildContext context,
    LoadBalancingState state,
  ) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'IP Routing Table',
                style: Theme.of(context).textTheme.titleMedium,
              ),
              if (state.routingTableStatus != DataStatus.loading)
                IconButton(
                  icon: const Icon(Icons.refresh),
                  tooltip: 'Refresh Routing Table',
                  onPressed: state.credentials == null
                      ? null
                      : () {
                          context.read<LoadBalancingBloc>().add(
                            FetchRoutingTableRequested(),
                          );
                        },
                )
              else
                const SizedBox(
                  height: 24,
                  width: 24,
                  child: CircularProgressIndicator(strokeWidth: 2),
                ),
            ],
          ),
          const SizedBox(height: 8),
          if (state.routingTableStatus == DataStatus.loading &&
              state.routingTable == null)
            const Center(child: Text('Fetching...'))
          else if (state.routingTable != null)
            Container(
              padding: const EdgeInsets.all(8),
              color: Colors.black.withAlpha((255 * 0.3).round()),
              width: double.infinity,
              child: SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: Text(
                  state.routingTable!,
                  style: const TextStyle(fontFamily: 'monospace', fontSize: 12),
                ),
              ),
            )
          else
            const Text('Press refresh to view the routing table.'),
        ],
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\load_balancing\widgets\ecmp_form.dart ---

// lib/presentation/screens/load_balancing/widgets/ecmp_form.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_event.dart' as events;
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart';

class EcmpForm extends StatefulWidget {
  const EcmpForm({super.key});

  @override
  State<EcmpForm> createState() => _EcmpFormState();
}

class _EcmpFormState extends State<EcmpForm> {
  final _formKey = GlobalKey<FormState>();
  final List<TextEditingController> _gatewayControllers = [];

  @override
  void dispose() {
    // Ensure all dynamically created controllers are disposed
    for (final controller in _gatewayControllers) {
      controller.dispose();
    }
    super.dispose();
  }

  void _addGatewayField() {
    setState(() {
      _gatewayControllers.add(TextEditingController());
    });
  }

  void _removeGatewayField(int index) {
    // Dispose the controller before removing it from the list
    _gatewayControllers[index].dispose();
    setState(() {
      _gatewayControllers.removeAt(index);
    });
  }

  void _applyEcmpConfig() {
    if (_formKey.currentState!.validate()) {
      // Collect the final list of gateways from the UI controllers.
      // The BLoC will handle the comparison.
      final gateways = _gatewayControllers
          .map((controller) => controller.text.trim())
          .where((ip) => ip.isNotEmpty) // Filter out empty fields
          .toList();
      
      context.read<LoadBalancingBloc>().add(
            events.ApplyEcmpConfig(finalGateways: gateways),
          );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      clipBehavior: Clip.antiAlias,
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Text(
                'ECMP Settings',
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              Text(
                'The app automatically detects existing gateways. Edit, add, or clear fields to update the configuration.',
                style: Theme.of(context).textTheme.bodyMedium,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),

              // BlocConsumer handles both listening to state changes and building the UI
              BlocConsumer<LoadBalancingBloc, LoadBalancingState>(
                // Listen only when the list of initial gateways changes
                listenWhen: (prev, curr) => prev.initialEcmpGateways != curr.initialEcmpGateways,
                listener: (context, state) {
                  _updateControllersFromState(state.initialEcmpGateways);
                },
                // Build the UI based on the current state
                buildWhen: (prev, curr) => 
                    prev.initialEcmpGateways != curr.initialEcmpGateways || 
                    prev.routingTableStatus != curr.routingTableStatus,
                builder: (context, state) {
                  // Show a loading indicator while the config is being read for the first time
                  if (state.routingTableStatus == DataStatus.loading && _gatewayControllers.isEmpty) {
                    return const Padding(
                      padding: EdgeInsets.symmetric(vertical: 20.0),
                      child: Center(child: Text("Reading router configuration...")),
                    );
                  }
                  
                  // Once loaded, build the dynamic list of fields
                  return ListView.separated(
                    physics: const NeverScrollableScrollPhysics(),
                    shrinkWrap: true,
                    itemCount: _gatewayControllers.length,
                    itemBuilder: (context, index) {
                      return Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Expanded(
                            child: _GatewayInputField(
                              key: ValueKey('gateway_field_$index'),
                              controller: _gatewayControllers[index],
                              label: 'Gateway ${index + 1}',
                            ),
                          ),
                          // Allow removing fields if there is more than one
                          if (_gatewayControllers.length > 1)
                            Padding(
                              padding: const EdgeInsets.only(left: 8.0, top: 8.0),
                              child: IconButton(
                                icon: const Icon(Icons.remove_circle_outline, color: Colors.redAccent),
                                onPressed: () => _removeGatewayField(index),
                                tooltip: 'Remove Gateway',
                              ),
                            ),
                        ],
                      );
                    },
                    separatorBuilder: (context, index) => const SizedBox(height: 16),
                  );
                },
              ),
              const SizedBox(height: 16),
              OutlinedButton.icon(
                onPressed: _addGatewayField,
                icon: const Icon(Icons.add),
                label: const Text('Add Gateway'),
                style: OutlinedButton.styleFrom(
                  side: BorderSide(color: Theme.of(context).colorScheme.primary),
                ),
              ),
              const SizedBox(height: 24),
              BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
                // Rebuild the button only when the overall status changes
                buildWhen: (prev, curr) => prev.status != curr.status,
                builder: (context, state) {
                  if (state.status == DataStatus.loading) {
                    return const Center(child: CircularProgressIndicator());
                  }
                  return ElevatedButton.icon(
                    onPressed: _applyEcmpConfig,
                    icon: const Icon(Icons.settings_applications),
                    label: const Text('Apply Changes'),
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      textStyle: const TextStyle(fontSize: 16)
                    ),
                  );
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  /// **CORRECTED LOGIC**
  /// Safely updates the list of controllers based on the BLoC state.
  void _updateControllersFromState(List<String> newGateways) {
    // First, dispose all existing controllers to prevent memory leaks.
    for (final controller in _gatewayControllers) {
      controller.dispose();
    }
    _gatewayControllers.clear();

    // Create new controllers for each gateway found on the router.
    for (final ip in newGateways) {
      _gatewayControllers.add(TextEditingController(text: ip));
    }

    // **MODIFIED:** If the list is empty after checking the router, 
    // add one blank field to give the user a starting point.
    if (_gatewayControllers.isEmpty) {
      _gatewayControllers.add(TextEditingController());
    }

    // Trigger a rebuild to show the new set of controllers.
    if(mounted) {
      setState(() {});
    }
  }
}

/// **CORRECTED AND OPTIMIZED WIDGET**
/// This widget is now structured to only rebuild the necessary parts on ping updates.
class _GatewayInputField extends StatelessWidget {
  final TextEditingController controller;
  final String label;

  const _GatewayInputField({
    super.key,
    required this.controller,
    required this.label,
  });

  static final _ipRegex = RegExp(r'^(\d{1,3}\.){3}\d{1,3}$');

  bool _isValidIp(String ip) {
    if (ip.trim().isEmpty) return false;
    if (!_ipRegex.hasMatch(ip.trim())) return false;
    final parts = ip.split('.');
    for (final part in parts) {
      final num = int.tryParse(part);
      if (num == null || num < 0 || num > 255) return false;
    }
    return true;
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // The TextFormField is no longer inside a BlocBuilder that listens to pings.
        TextFormField(
          controller: controller,
          validator: (value) {
            final text = value?.trim() ?? '';
            if (text.isNotEmpty && !_isValidIp(text)) {
              return 'Invalid IP address format';
            }
            return null;
          },
          decoration: InputDecoration(
            labelText: label,
            hintText: 'e.g., 192.168.1.1',
            border: const OutlineInputBorder(),
            // The suffix icon IS rebuilt based on ping status.
            suffixIcon: BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
              buildWhen: (prev, curr) {
                // Rebuild only if the ping status for THIS specific IP changes.
                final ip = controller.text.trim();
                return prev.pingingIp == ip || curr.pingingIp == ip || prev.pingResults[ip] != curr.pingResults[ip];
              },
              builder: (context, state) {
                final ipAddress = controller.text.trim();
                final isPinging = state.pingingIp == ipAddress;
                final canPing = ipAddress.isNotEmpty && _isValidIp(ipAddress) && !isPinging;

                if (isPinging) {
                  return const Padding(
                    padding: EdgeInsets.all(12.0),
                    child: SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    ),
                  );
                }
                return IconButton(
                  icon: const Icon(Icons.network_ping),
                  tooltip: canPing ? 'Ping Gateway' : 'Enter a valid IP to ping',
                  onPressed: canPing
                      ? () {
                          context
                              .read<LoadBalancingBloc>()
                              .add(events.PingGatewayRequested(ipAddress));
                        }
                      : null,
                );
              },
            ),
          ),
        ),
        // The ping result box IS also rebuilt based on ping status.
        BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
           buildWhen: (prev, curr) {
                final ip = controller.text.trim();
                return prev.pingResults[ip] != curr.pingResults[ip];
              },
          builder: (context, state) {
            final ipAddress = controller.text.trim();
            final pingResult = state.pingResults[ipAddress];

            if (pingResult == null) {
              return const SizedBox.shrink(); // Return nothing if there is no result
            }
            return Padding(
              padding: const EdgeInsets.only(top: 8.0),
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                decoration: BoxDecoration(
                  color: pingResult.toLowerCase().contains('success')
                      ? Colors.green.withAlpha(30)
                      : Colors.orange.withAlpha(30),
                  border: Border.all(
                    color: pingResult.toLowerCase().contains('success')
                        ? Colors.green
                        : Colors.orange,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(
                      pingResult.toLowerCase().contains('success')
                          ? Icons.check_circle
                          : Icons.warning,
                      size: 16,
                      color: pingResult.toLowerCase().contains('success')
                          ? Colors.green
                          : Colors.orange,
                    ),
                    const SizedBox(width: 8),
                    Expanded(child: Text(pingResult)),
                    IconButton(
                      icon: const Icon(Icons.close, size: 16),
                      onPressed: () {
                        context
                            .read<LoadBalancingBloc>()
                            .add(events.ClearPingResult(ipAddress));
                      },
                      tooltip: 'Clear Result',
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ],
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\load_balancing\widgets\pbr_form.dart ---

// lib/presentation/screens/load_balancing/widgets/pbr_form.dart
import 'package:flutter/material.dart';
// import 'package:go_router/go_router.dart'; // این import دیگر لازم نیست و حذف میشود
import 'pbr_rule_list_item.dart';

class PbrForm extends StatelessWidget {
  const PbrForm({super.key});

  @override
  Widget build(BuildContext context) {
    // Scaffold حذف شد. ویجت اصلی اکنون Padding است
    return Padding(
      padding: const EdgeInsets.only(top: 16.0),
      child: ListView(
        shrinkWrap: true,
        physics: const NeverScrollableScrollPhysics(),
        children: const [
          // لیست رول های PBR مثل قبل نمایش داده میشود
          PbrRuleListItem(
            ruleName: 'Finance_Web_Traffic',
            matchCondition: 'From: 192.168.10.0/24, Proto: TCP, Port: 443',
            action: 'Next-Hop: 192.168.2.1',
          ),
          SizedBox(height: 16),
          PbrRuleListItem(
            ruleName: 'CCTV_Feed_To_Server',
            matchCondition: 'From: 192.168.50.10, To: 10.0.0.5',
            action: 'Next-Hop: 10.10.10.1',
          ),
        ],
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\load_balancing\widgets\pbr_rule_form_sections.dart ---

// lib/presentation/screens/load_balancing/widgets/pbr_rule_form_sections.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart';
import 'package:load_balance/presentation/bloc/pbr_rule_form/pbr_rule_form_bloc.dart';
import 'package:load_balance/presentation/bloc/pbr_rule_form/pbr_rule_form_event.dart';
import 'package:load_balance/presentation/bloc/pbr_rule_form/pbr_rule_form_state.dart';

// -- Section 1: Widget for identifying traffic --
class TrafficMatchCard extends StatelessWidget {
  const TrafficMatchCard({super.key});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Section 1: Identify Traffic', style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 24),
            TextFormField(
              decoration: const InputDecoration(labelText: 'Rule Name', hintText: 'e.g., Finance_Web_Traffic'),
              onChanged: (value) => context.read<PbrRuleFormBloc>().add(RuleNameChanged(value)),
            ),
            const SizedBox(height: 16),
            TextFormField(
              decoration: const InputDecoration(labelText: 'Source IP Address', hintText: 'e.g., 192.168.10.0/24 or "any"'),
              initialValue: 'any',
              onChanged: (value) => context.read<PbrRuleFormBloc>().add(SourceAddressChanged(value)),
            ),
            const SizedBox(height: 16),
            // TODO: Add onChanged for other text fields like Destination Address and Port
            TextFormField(
              decoration: const InputDecoration(labelText: 'Destination IP Address', hintText: 'e.g., 8.8.8.8 or "any"'),
              initialValue: 'any',
            ),
            const SizedBox(height: 16),
            BlocBuilder<PbrRuleFormBloc, PbrRuleFormState>(
              buildWhen: (p, c) => p.protocol != c.protocol,
              builder: (context, state) {
                return DropdownButtonFormField<String>(
                  decoration: const InputDecoration(labelText: 'Protocol'),
                  value: state.protocol,
                  items: ['any', 'tcp', 'udp', 'icmp']
                      .map((label) => DropdownMenuItem(value: label, child: Text(label.toUpperCase())))
                      .toList(),
                  onChanged: (value) {
                    if (value != null) {
                      context.read<PbrRuleFormBloc>().add(ProtocolChanged(value));
                    }
                  },
                );
              },
            ),
            const SizedBox(height: 16),
            TextFormField(
              decoration: const InputDecoration(labelText: 'Destination Port (for TCP/UDP)', hintText: 'e.g., 443 or "any"'),
              initialValue: 'any',
            ),
          ],
        ),
      ),
    );
  }
}

// -- Section 2: Widget for the routing action --
class RoutingActionCard extends StatelessWidget {
  const RoutingActionCard({super.key});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: BlocBuilder<PbrRuleFormBloc, PbrRuleFormState>(
          builder: (context, state) {
            if (state.formStatus == DataStatus.loading) {
              return const Center(child: CircularProgressIndicator());
            }

            final bloc = context.read<PbrRuleFormBloc>();
            final interfaceItems = state.availableInterfaces
                .map((iface) => DropdownMenuItem(value: iface.name, child: Text(iface.name)))
                .toList();

            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('Section 2: Define Action', style: Theme.of(context).textTheme.titleLarge),
                const SizedBox(height: 8),
                RadioListTile<PbrActionType>(
                  title: const Text('Set Next-Hop Gateway'),
                  value: PbrActionType.nextHop,
                  groupValue: state.actionType,
                  onChanged: (value) => bloc.add(ActionTypeChanged(value!)),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: TextFormField(
                    enabled: state.actionType == PbrActionType.nextHop,
                    decoration: const InputDecoration(labelText: 'Gateway IP Address', hintText: 'e.g., 192.168.2.1'),
                    onChanged: (value) => bloc.add(NextHopChanged(value)),
                  ),
                ),
                RadioListTile<PbrActionType>(
                  title: const Text('Set Egress Interface'),
                  value: PbrActionType.interface,
                  groupValue: state.actionType,
                  onChanged: (value) => bloc.add(ActionTypeChanged(value!)),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  child: DropdownButtonFormField<String>(
                    value: state.egressInterface.isNotEmpty ? state.egressInterface : null,
                    decoration: const InputDecoration(labelText: 'Interface'),
                    items: interfaceItems,
                    // **تغییر اصلی در اینجا است**
                    // با null کردن onChanged، ویجت به طور خودکار غیرفعال میشود
                    onChanged: state.actionType == PbrActionType.interface
                        ? (value) {
                            if (value != null) bloc.add(EgressInterfaceChanged(value));
                          }
                        : null,
                  ),
                ),
              ],
            );
          },
        ),
      ),
    );
  }
}

// -- Section 3: Widget for applying to an interface --
class ApplyInterfaceCard extends StatelessWidget {
  const ApplyInterfaceCard({super.key});

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: BlocBuilder<PbrRuleFormBloc, PbrRuleFormState>(
          builder: (context, state) {
            if (state.formStatus == DataStatus.loading) {
              return const SizedBox(height: 50); // Placeholder for loading
            }

            final bloc = context.read<PbrRuleFormBloc>();
            final interfaceItems = state.availableInterfaces
                .map((iface) => DropdownMenuItem(value: iface.name, child: Text(iface.name)))
                .toList();

            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('Section 3: Apply Policy', style: Theme.of(context).textTheme.titleLarge),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  value: state.applyToInterface.isNotEmpty ? state.applyToInterface : null,
                  decoration: const InputDecoration(
                    labelText: 'Apply to Inbound Traffic on Interface',
                    border: OutlineInputBorder(),
                  ),
                  items: interfaceItems,
                  onChanged: (value) {
                    if (value != null) bloc.add(ApplyToInterfaceChanged(value));
                  },
                ),
              ],
            );
          },
        ),
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\load_balancing\widgets\pbr_rule_list_item.dart ---

// lib/presentation/screens/load_balancing/widgets/pbr_rule_list_item.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_bloc.dart';

class PbrRuleListItem extends StatelessWidget {
  final String ruleName;
  final String matchCondition;
  final String action;

  const PbrRuleListItem({
    super.key,
    required this.ruleName,
    required this.matchCondition,
    required this.action,
  });

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(ruleName, style: textTheme.titleMedium),
            const SizedBox(height: 12),
            _buildInfoRow(
              context,
              icon: Icons.filter_alt_outlined,
              title: 'Match:',
              value: matchCondition,
            ),
            const SizedBox(height: 8),
            _buildInfoRow(
              context,
              icon: Icons.alt_route_outlined,
              title: 'Action:',
              value: action,
            ),
            const Divider(height: 24),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                IconButton(
                  icon: const Icon(Icons.edit_outlined),
                  tooltip: 'Edit Rule',
                  onPressed: () {
                    // credentials را از state بلاک میخوانیم
                    final credentials = context
                        .read<LoadBalancingBloc>()
                        .state
                        .credentials;
                    if (credentials != null) {
                      context.goNamed(
                        'edit_pbr_rule',
                        pathParameters: {'ruleId': ruleName},
                        extra:
                            credentials, // credentials را اینجا هم پاس میدهیم
                      );
                    }
                  },
                ),
                IconButton(
                  icon: Icon(Icons.delete_outline, color: Colors.red.shade300),
                  tooltip: 'Delete Rule',
                  onPressed: () {
                    // TODO: Show delete confirmation dialog
                  },
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String value,
  }) {
    final textTheme = Theme.of(context).textTheme;
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, size: 16, color: Theme.of(context).colorScheme.primary),
        const SizedBox(width: 8),
        Text(
          title,
          style: textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.bold),
        ),
        const SizedBox(width: 4),
        Expanded(child: Text(value, style: textTheme.bodyMedium)),
      ],
    );
  }
}
