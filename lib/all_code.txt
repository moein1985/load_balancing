
--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\main.dart ---

// lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/core/router/app_router.dart';
import 'package:load_balance/data/datasources/remote_datasource_impl.dart';
import 'package:load_balance/data/repositories/device_repository_impl.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';
import 'package:load_balance/domain/usecases/apply_ecmp_config.dart';
import 'package:load_balance/domain/usecases/check_credentials.dart';
import 'package:load_balance/domain/usecases/get_interfaces.dart';
import 'package:load_balance/domain/usecases/get_routing_table.dart';
import 'package:load_balance/domain/usecases/ping_gateway.dart';
import 'package:load_balance/presentation/bloc/connection/connection_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_bloc.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return RepositoryProvider<DeviceRepository>(
      create: (context) => DeviceRepositoryImpl(
        remoteDataSource: RemoteDataSourceImpl(),
      ),
      child: MultiBlocProvider(
        providers: [
          BlocProvider(
            create: (context) => ConnectionBloc(
              checkCredentials: CheckCredentials(context.read<DeviceRepository>()),
            ),
          ),
          BlocProvider(
            create: (context) {
              final repository = context.read<DeviceRepository>();
              return LoadBalancingBloc(
                getInterfaces: GetInterfaces(repository),
                getRoutingTable: GetRoutingTable(repository),
                pingGateway: PingGateway(repository),
                // Provide the new use case to the BLoC
                applyEcmpConfig: ApplyEcmpConfig(repository),
              );
            },
          ),
        ],
        child: MaterialApp.router(
          title: 'Cisco Load Balancer',
          theme: ThemeData(
            primarySwatch: Colors.blue,
            useMaterial3: true,
            brightness: Brightness.dark,
            cardTheme: CardThemeData(elevation: 2, shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0))),
            inputDecorationTheme: const InputDecorationTheme(border: OutlineInputBorder(borderRadius: BorderRadius.all(Radius.circular(12.0)))),
            segmentedButtonTheme: SegmentedButtonThemeData(
              style: ButtonStyle(shape: WidgetStateProperty.all(RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)))),
            ),
          ),
          routerConfig: AppRouter.router,
        ),
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\test.dart ---

// import 'package:dart_ping/dart_ping.dart';

// void main() async {
//   // Create ping object with desired args
//   final ping = Ping('google.com', count: 5);

//   // [Optional]
//   // Preview command that will be run (helpful for debugging)
//   print('Running command: ${ping.command}');

//   // Begin ping process and listen for output
//   ping.stream.listen((event) {
//     print(event);
//   });
// }

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\core\error\failure.dart ---

// core/error/failure.dart
import 'package:equatable/equatable.dart';

abstract class Failure extends Equatable {
  final String message;
  const Failure(this.message);

  @override
  List<Object> get props => [message];
}

// Failure specific to server/connection errors
class ServerFailure extends Failure {
  const ServerFailure(super.message);
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\core\router\app_router.dart ---

// core/router/app_router.dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/presentation/screens/load_balancing/load_balancing_screen.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';

class AppRouter {
  static final GoRouter router = GoRouter(
    initialLocation: '/',
    routes: [
      GoRoute(
        path: '/',
        name: 'connection',
        builder: (BuildContext context, GoRouterState state) {
          return const ConnectionScreen();
        },
      ),
      GoRoute(
        path: '/config',
        name: 'config',
        builder: (BuildContext context, GoRouterState state) {
          // Receive the credentials object from the previous screen
          final credentials = state.extra as DeviceCredentials;
          return LoadBalancingScreen(credentials: credentials);
        },
      ),
    ],
  );
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\core\usecase\usecase.dart ---


--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\datasources\remote_datasource.dart ---

// lib/data/datasources/remote_datasource.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';

abstract class RemoteDataSource {
  Future<void> checkRestApiCredentials(DeviceCredentials credentials);
  Future<List<RouterInterface>> fetchInterfaces(DeviceCredentials credentials);
  Future<String> getRoutingTable(DeviceCredentials credentials);
  Future<String> pingGateway(DeviceCredentials credentials, String ipAddress);
  // New method to apply ECMP configuration
  Future<String> applyEcmpConfig(DeviceCredentials credentials, String gateway1, String gateway2);
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\datasources\remote_datasource_impl.dart ---

// lib/data/datasources/remote_datasource_impl.dart
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';
import 'package:load_balance/data/datasources/ssh_client_handler.dart';
import 'package:load_balance/data/datasources/telnet_client_handler.dart';
import 'package:load_balance/data/datasources/restapi_client_handler.dart';
import 'remote_datasource.dart';

class RemoteDataSourceImpl implements RemoteDataSource {
  final SshClientHandler _sshHandler = SshClientHandler();
  final TelnetClientHandler _telnetHandler = TelnetClientHandler();
  final RestApiClientHandler _restApiHandler = RestApiClientHandler();

  void _logDebug(String message) {
    if (kDebugMode) {
      debugPrint('[REMOTE_DS] $message');
    }
  }

  @override
  Future<List<RouterInterface>> fetchInterfaces(
      DeviceCredentials credentials) async {
    _logDebug('Fetching interface list - ${credentials.type}');
    String briefResult;
    String detailedResult;

    if (credentials.type == ConnectionType.ssh) {
      briefResult = await _sshHandler.fetchInterfaces(credentials);
      detailedResult = await _sshHandler.fetchDetailedInterfaces(credentials);
    } else {
      briefResult = await _telnetHandler.fetchInterfaces(credentials);
      detailedResult = await _telnetHandler.fetchDetailedInterfaces(credentials);
    }

    return _parseDetailedInterfaces(briefResult, detailedResult);
  }

  List<RouterInterface> _parseDetailedInterfaces(String briefResult, String detailedResult) {
    final interfaces = <RouterInterface>[];
    final briefLines = briefResult.split('\n');
    final briefRegex = RegExp(
        r'^(\S+)\s+([\d\.]+|unassigned)\s+\w+\s+\w+\s+(up|down|administratively down)');
    
    // First, find the main interfaces from the brief output
    final mainInterfaces = <Map<String, String>>[];
    for (final line in briefLines) {
      final match = briefRegex.firstMatch(line);
      if (match != null && match.group(2) != 'unassigned') {
        final interfaceName = match.group(1)!;
        // Ignore NVI0 as it's a virtual interface
        if (!interfaceName.startsWith('NVI')) {
          mainInterfaces.add({
            'name': interfaceName,
            'primaryIp': match.group(2)!,
            'status': match.group(3)!,
          });
        }
      }
    }

    // Then, find secondary addresses from the detailed config
    final secondaryIps = _extractSecondaryIps(detailedResult);
    
    // Build the final interface list
    for (final interface in mainInterfaces) {
      final interfaceName = interface['name']!;
      final primaryIp = interface['primaryIp']!;
      final status = interface['status']!;

      // Add the primary address
      interfaces.add(RouterInterface(
        name: interfaceName,
        ipAddress: primaryIp,
        status: status,
      ));
      
      // Add any secondary addresses
      final secondaries = secondaryIps[interfaceName] ?? [];
      for (final secondaryIp in secondaries) {
        interfaces.add(RouterInterface(
          name: '$interfaceName (Secondary)',
          ipAddress: secondaryIp,
          status: status,
        ));
      }
    }

    _logDebug('${interfaces.length} interfaces processed');
    return interfaces;
  }

  Map<String, List<String>> _extractSecondaryIps(String configOutput) {
    final secondaryIps = <String, List<String>>{};
    final lines = configOutput.split('\n');
    String? currentInterface;

    for (final line in lines) {
      final trimmedLine = line.trim();
      // Find the start of an interface configuration
      if (trimmedLine.startsWith('interface ')) {
        currentInterface = trimmedLine.split(' ')[1];
        secondaryIps[currentInterface] = [];
      }

      // Find secondary IP addresses
      if (currentInterface != null && trimmedLine.contains('ip address') && trimmedLine.contains('secondary')) {
        final parts = trimmedLine.split(' ');
        if (parts.length >= 4) {
          final ipAddress = parts[2];
          if (_isValidIpAddress(ipAddress)) {
            secondaryIps[currentInterface]!.add(ipAddress);
          }
        }
      }
    }

    return secondaryIps;
  }

  @override
  Future<String> getRoutingTable(DeviceCredentials credentials) async {
    _logDebug('Fetching routing table - ${credentials.type}');

    String rawResult;
    if (credentials.type == ConnectionType.ssh) {
      rawResult = await _sshHandler.getRoutingTable(credentials);
    } else {
      rawResult = await _telnetHandler.getRoutingTable(credentials);
    }

    return _cleanRoutingTableOutput(rawResult);
  }

  String _cleanRoutingTableOutput(String rawResult) {
    _logDebug('Cleaning routing table output, input length: ${rawResult.length}');
    final lines = rawResult.split('\n');
    final cleanLines = <String>[];
    bool routeStarted = false;
    for (final line in lines) {
      final trimmedLine = line.trim();
      // Start of the routing table
      if (trimmedLine.startsWith('Codes:') ||
          trimmedLine.startsWith('Gateway of last resort')) {
        routeStarted = true;
      }

      // End of the routing table (prompt)
      if (routeStarted && (trimmedLine.endsWith('#') || trimmedLine.endsWith('>'))) {
        break;
      }

      if (routeStarted && trimmedLine.isNotEmpty) {
        cleanLines.add(line);
      }
    }

    final result = cleanLines.join('\n').trim();
    _logDebug('Routing table cleaned, length: ${result.length}');
    return result;
  }

  @override
  Future<String> pingGateway(
      DeviceCredentials credentials, String ipAddress) async {
    _logDebug('Starting ping for IP: $ipAddress - ${credentials.type}');
    if (ipAddress.trim().isEmpty) {
      return 'Error: IP address cannot be empty.';
    }

    if (!_isValidIpAddress(ipAddress.trim())) {
      return 'Error: Invalid IP address format.';
    }

    final cleanIp = ipAddress.trim();

    try {
      if (credentials.type == ConnectionType.ssh) {
        return await _sshHandler.pingGateway(credentials, cleanIp);
      } else {
        return await _telnetHandler.pingGateway(credentials, cleanIp);
      }
    } catch (e) {
      _logDebug('Error in ping: $e');
      if (e is ServerFailure) {
        return 'Error: ${e.message}';
      }
      return 'Error in ping: ${e.toString()}';
    }
  }

  bool _isValidIpAddress(String ip) {
    final ipRegex = RegExp(r'^(\d{1,3}\.){3}\d{1,3}$');
    if (!ipRegex.hasMatch(ip)) return false;
    final parts = ip.split('.');
    for (final part in parts) {
      final num = int.tryParse(part);
      if (num == null || num < 0 || num > 255) return false;
    }
    return true;
  }

  @override
  Future<void> checkRestApiCredentials(DeviceCredentials credentials) async {
    _logDebug('Checking REST API credentials');
    return await _restApiHandler.checkCredentials(credentials);
  }

  // Implementation for the new ECMP method
  @override
  Future<String> applyEcmpConfig(DeviceCredentials credentials, String gateway1, String gateway2) async {
    _logDebug('Applying ECMP config - ${credentials.type}');
    try {
       if (credentials.type == ConnectionType.ssh) {
        return await _sshHandler.applyEcmpConfig(credentials, gateway1, gateway2);
      } else if (credentials.type == ConnectionType.telnet) {
        return await _telnetHandler.applyEcmpConfig(credentials, gateway1, gateway2);
      } else {
        return 'Configuration via REST API is not yet supported.';
      }
    } on ServerFailure catch (e) {
      _logDebug('ServerFailure applying ECMP config: ${e.message}');
      return e.message;
    } catch (e) {
      _logDebug('Unknown error applying ECMP config: ${e.toString()}');
      return 'An unknown error occurred: ${e.toString()}';
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\datasources\restapi_client_handler.dart ---

// lib/data/datasources/restapi_client_handler.dart
import 'dart:convert';
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:dio/io.dart';
import 'package:flutter/foundation.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';

class RestApiClientHandler {
  void _logDebug(String message) {
    if (kDebugMode) {
      debugPrint('[REST API] $message');
    }
  }

  Future<void> checkCredentials(DeviceCredentials credentials) async {
    _logDebug('Checking REST API credentials');
    
    final dio = Dio();
    final String basicAuth = 'Basic ${base64Encode(
        utf8.encode('${credentials.username}:${credentials.password}'))}';
    
    // Allow self-signed certificates for lab environments
    (dio.httpClientAdapter as IOHttpClientAdapter).createHttpClient = () {
      final client = HttpClient();
      client.badCertificateCallback = (cert, host, port) {
        _logDebug('Warning: Untrusted SSL certificate for $host:$port');
        return true;
      };
      return client;
    };

    try {
      final response = await dio.get(
        'https://${credentials.ip}/restconf/data/Cisco-IOS-XE-native:native',
        options: Options(
          headers: {
            'Authorization': basicAuth,
            'Accept': 'application/yang-data+json'
          },
          receiveTimeout: const Duration(seconds: 10),
          sendTimeout: const Duration(seconds: 10),
        ),
      );
      _logDebug('REST API connection successful - Response code: ${response.statusCode}');
    } on DioException catch (e) {
      _logDebug('REST API Error: ${e.type} - ${e.message}');
      if (e.response?.statusCode == 401) {
        throw const ServerFailure(
            'Authentication failed. Check your username and password.');
      } else if (e.type == DioExceptionType.connectionTimeout ||
          e.type == DioExceptionType.receiveTimeout) {
        throw const ServerFailure(
            'Connection timed out. Check the IP and ensure RESTCONF is enabled.');
      } else if (e.type == DioExceptionType.connectionError) {
        throw const ServerFailure(
            'Connection error. Check the IP and network accessibility.');
      } else {
        throw ServerFailure(
            'RESTCONF Error: ${e.message ?? 'Unknown Dio error'}');
      }
    } catch (e) {
      _logDebug('Unknown REST API error: $e');
      throw ServerFailure('An unknown error occurred: ${e.toString()}');
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\datasources\ssh_client_handler.dart ---

// lib/data/datasources/ssh_client_handler.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:dartssh2/dartssh2.dart';
import 'package:flutter/foundation.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';

class SshClientHandler {
  static const _commandTimeout = Duration(seconds: 30);
  static const _connectionTimeout = Duration(seconds: 10);
  static const _delayBetweenCommands = Duration(milliseconds: 500);

  void _logDebug(String message) {
    if (kDebugMode) {
      debugPrint('[SSH] $message');
    }
  }

  Future<SSHClient> _createSshClient(DeviceCredentials credentials) async {
    _logDebug('Creating SSH connection to ${credentials.ip}');
    try {
      final socket = await SSHSocket.connect(
        credentials.ip,
        22,
        timeout: _connectionTimeout,
      );
      final client = SSHClient(
        socket,
        username: credentials.username,
        onPasswordRequest: () => credentials.password,
      );
      _logDebug('SSH connection established');
      return client;
    } on TimeoutException {
      _logDebug('Error: SSH connection timed out');
      throw const ServerFailure('Connection timed out. Please check the IP address and port.');
    } on SocketException catch (e) {
      _logDebug('Error: SSH connection failed - ${e.message}');
      throw const ServerFailure('Unable to connect to the device. Check the IP address and port.');
    } catch (e) {
      final errorMsg = e.toString().toLowerCase();
      if (errorMsg.contains('auth')) {
        _logDebug('Error: SSH authentication failed');
        throw const ServerFailure('Authentication failed. Check your username and password.');
      }
      _logDebug('Error: SSH - $e');
      throw ServerFailure('SSH Error: ${e.toString()}');
    }
  }

  Future<String> _executeSshCommand(SSHClient client, String command) async {
    try {
      _logDebug('Executing SSH command: $command');
      final result = await client.run(command).timeout(_commandTimeout);
      final output = utf8.decode(result);
      _logDebug('SSH command executed, output length: ${output.length}');
      return output;
    } catch (e) {
      _logDebug('Error executing SSH command: $e');
      rethrow;
    }
  }

  Future<String> _executeSshCommandsWithShell(SSHClient client, List<String> commands) async {
    _logDebug('Starting execution of SSH commands with Shell');
    try {
      final shell = await client.shell(
        pty: SSHPtyConfig(
          width: 80,
          height: 24,
        ),
      );
      final completer = Completer<String>();
      final output = StringBuffer();
      bool isReady = false;
      int commandIndex = 0;

      void sendNextCommand() {
        if (commandIndex < commands.length) {
          final command = commands[commandIndex];
          _logDebug('Sending SSH Shell command: $command');
          shell.stdin.add(utf8.encode('$command\n'));
          commandIndex++;
        }
      }

      shell.stdout.cast<List<int>>().transform(utf8.decoder).listen((data) {
        output.write(data);
        _logDebug('SSH Shell Output: ${data.replaceAll('\r\n', '\\n').replaceAll('\n', '\\n')}');

        // Wait for the prompt before sending the first command
        if (!isReady && (data.contains('#') || data.contains('>'))) {
          isReady = true;
          sendNextCommand();
        }
        // After a command is sent, wait for the next prompt to send the next command
        else if (isReady && (data.contains('#') || data.contains('>'))) {
          if (commandIndex < commands.length) {
            sendNextCommand();
          } else {
            // All commands sent, close the shell and complete
            shell.close();
            if (!completer.isCompleted) {
              completer.complete(output.toString());
            }
          }
        }
      });

      shell.stderr.cast<List<int>>().transform(utf8.decoder).listen((data) {
        _logDebug('SSH Shell Error: $data');
        output.write(data);
      });

      // General timeout for the whole operation
      Timer(_commandTimeout, () {
        if (!completer.isCompleted) {
          shell.close();
          completer.completeError(TimeoutException('SSH Shell operation timed out', _commandTimeout));
        }
      });

      return await completer.future;
    } catch (e) {
      _logDebug('Error in SSH Shell: $e');
      rethrow;
    }
  }

  Future<String> fetchInterfaces(DeviceCredentials credentials) async {
    SSHClient? client;
    try {
      client = await _createSshClient(credentials);
      final result = await _executeSshCommand(client, 'show ip interface brief');
      _logDebug('SSH interfaces fetched');
      return result;
    } catch (e) {
      _logDebug('Error fetching SSH interfaces: $e');
      rethrow;
    } finally {
      client?.close();
    }
  }

  Future<String> fetchDetailedInterfaces(DeviceCredentials credentials) async {
    SSHClient? client;
    try {
      client = await _createSshClient(credentials);
      final result = await _executeSshCommand(client, 'show running-config');
      _logDebug('SSH detailed config fetched');
      return result;
    } catch (e) {
      _logDebug('Error fetching SSH detailed config: $e');
      rethrow;
    } finally {
      client?.close();
    }
  }

  Future<String> getRoutingTable(DeviceCredentials credentials) async {
    SSHClient? client;
    try {
      client = await _createSshClient(credentials);
      try {
        final result = await _executeSshCommandsWithShell(
            client, ['terminal length 0', 'show ip route']);
        _logDebug('SSH routing table fetched with Shell');
        return result;
      } catch (e) {
        _logDebug('Error in SSH Shell, trying legacy method: $e');
        await _executeSshCommand(client, 'terminal length 0');
        await Future.delayed(_delayBetweenCommands);
        final result = await _executeSshCommand(client, 'show ip route');
        _logDebug('SSH routing table fetched with legacy method');
        return result;
      }
    } catch (e) {
      _logDebug('Error fetching SSH routing table: $e');
      rethrow;
    } finally {
      client?.close();
    }
  }

  Future<String> pingGateway(DeviceCredentials credentials, String ipAddress) async {
    _logDebug('Starting SSH ping for IP: $ipAddress');
    SSHClient? client;
    try {
      client = await _createSshClient(credentials);
      final result = await _executeSshCommand(client, 'ping $ipAddress repeat 5');

      _logDebug('SSH ping result received');
      return _analyzePingResult(result);
    } finally {
      client?.close();
    }
  }

  String _analyzePingResult(String output) {
    _logDebug('Analyzing ping result');
    if (output.contains('!!!!!') ||
        output.contains('Success rate is 100') ||
        output.contains('Success rate is 80')) {
      return 'Success! Gateway is reachable.';
    } else if (output.contains('.....') ||
        output.contains('Success rate is 0')) {
      return 'Timeout. Gateway is not reachable.';
    } else if (output.toLowerCase().contains('unknown host')) {
      return 'Error: Unknown host.';
    } else if (output.toLowerCase().contains('network unreachable')) {
      return 'Error: Network unreachable.';
    }

    return 'Ping failed. Check the IP or connection.';
  }

  // New method to apply ECMP configuration
  Future<String> applyEcmpConfig(DeviceCredentials credentials, String gateway1, String gateway2) async {
    _logDebug('Applying ECMP config for gateways: $gateway1, $gateway2');
    SSHClient? client;
    try {
      client = await _createSshClient(credentials);
      final commands = [
        'configure terminal',
        'ip route 0.0.0.0 0.0.0.0 $gateway1',
        'ip route 0.0.0.0 0.0.0.0 $gateway2',
        'end'
      ];
      final result = await _executeSshCommandsWithShell(client, commands);
      _logDebug('ECMP config commands executed');

      if (result.toLowerCase().contains('invalid input') || result.toLowerCase().contains('error')) {
          _logDebug('Error applying ECMP config: $result');
          return 'Failed to apply ECMP configuration. Router response: ${result.split('\n').lastWhere((line) => line.contains('%') || line.contains('^'), orElse: () => 'Unknown error')}';
      }
      
      return 'ECMP configuration applied successfully.';
    } catch (e) {
      _logDebug('Error applying ECMP config: $e');
      return 'An error occurred while applying ECMP configuration: ${e.toString()}';
    } finally {
      client?.close();
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\datasources\telnet_client_handler.dart ---

// lib/data/datasources/telnet_client_handler.dart
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:ctelnet/ctelnet.dart';

class TelnetClientHandler {
  static const _commandTimeout = Duration(seconds: 30); // Increased timeout
  static const _connectionTimeout = Duration(seconds: 20);

  void _logDebug(String message) {
    if (kDebugMode) {
      debugPrint('[TELNET] $message');
    }
  }

  Future<String> _executeTelnetCommands(
      DeviceCredentials credentials, List<String> commands) async {
    _logDebug('Starting execution of Telnet commands');
    final completer = Completer<String>();
    final outputBuffer = StringBuffer();
    CTelnetClient? client;
    StreamSubscription<Message>? subscription;

    var state = 'login';
    int commandIndex = 0;
    // Prepend 'terminal length 0' to avoid pagination
    final allCommands = ['terminal length 0', ...commands];
    Timer? timeoutTimer;

    // Setup timeout timer for the whole operation
    timeoutTimer = Timer(_commandTimeout, () {
      _logDebug('Telnet operation timed out');
      if (!completer.isCompleted) {
        client?.disconnect();
        completer.completeError(const ServerFailure("Telnet operation timed out."));
      }
    });

    client = CTelnetClient(
      host: credentials.ip,
      port: 23,
      timeout: _connectionTimeout,
      onConnect: () {
        _logDebug('Telnet connection established');
      },
      onDisconnect: () {
        _logDebug('Telnet connection closed');
        timeoutTimer?.cancel();
        if (!completer.isCompleted) {
          completer.complete(outputBuffer.toString());
        }
        subscription?.cancel();
      },
      onError: (error) {
        _logDebug('Telnet error: $error');
        timeoutTimer?.cancel();
        if (!completer.isCompleted) {
          completer.completeError(ServerFailure("Telnet Error: $error"));
        }
        subscription?.cancel();
      },
    );

    void executeNextCommand() {
      if (commandIndex < allCommands.length) {
        final cmd = allCommands[commandIndex];
        _logDebug("Sending Telnet: $cmd");
        client?.send('$cmd\n');
        commandIndex++;
      } else {
        // Short delay before disconnecting to ensure all output is received
        Timer(const Duration(seconds: 1), () {
          if (!completer.isCompleted) {
            client?.disconnect();
          }
        });
      }
    }

    try {
      subscription = (await client.connect())?.listen((data) {
        final receivedText = data.text.trim();
        outputBuffer.write(data.text);
        _logDebug("Telnet Received: ${receivedText.replaceAll('\r\n', ' ')}");

        switch (state) {
          case 'login':
            if (receivedText.toLowerCase().contains('username')) {
              client?.send('${credentials.username}\n');
            } else if (receivedText.toLowerCase().contains('password')) {
              client?.send('${credentials.password}\n');
            } else if (receivedText.endsWith('>')) {
              state = 'enable';
              client?.send('enable\n');
            } else if (receivedText.endsWith('#')) {
              state = 'executing';
              outputBuffer.clear(); // Clear buffer before starting commands
              executeNextCommand();
            }
            break;
          case 'enable':
            if (receivedText.toLowerCase().contains('password')) {
              client?.send('${credentials.enablePassword ?? ''}\n');
            } else if (receivedText.endsWith('#')) {
              state = 'executing';
              outputBuffer.clear(); // Clear buffer before starting commands
              executeNextCommand();
            }
            break;
          case 'executing':
            if (receivedText.endsWith('#')) {
              if (commandIndex < allCommands.length) {
                executeNextCommand();
              } else {
                // Short delay before disconnecting
                Timer(const Duration(seconds: 1), () {
                  if (!completer.isCompleted) {
                    client?.disconnect();
                  }
                });
              }
            }
            break;
        }
      });
    } catch (e) {
      _logDebug('Error on Telnet connect: $e');
      timeoutTimer.cancel();
      if (!completer.isCompleted) {
        completer.completeError(ServerFailure("Telnet connection failed: $e"));
      }
    }

    return completer.future;
  }

  Future<String> _executeTelnetPing(
      DeviceCredentials credentials, String ipAddress) async {
    _logDebug('Starting Telnet ping for IP: $ipAddress');
    final completer = Completer<String>();
    CTelnetClient? client;
    StreamSubscription<Message>? subscription;
    var state = 'login';
    final outputBuffer = StringBuffer();
    bool commandSent = false;
    Timer? timeoutTimer;

    // Setup timeout timer
    timeoutTimer = Timer(_commandTimeout, () {
      _logDebug('Ping operation timed out');
      if (!completer.isCompleted) {
        client?.disconnect();
        completer.complete('Timeout. Gateway is not reachable.');
      }
    });

    client = CTelnetClient(
      host: credentials.ip,
      port: 23,
      timeout: _connectionTimeout,
      onConnect: () => _logDebug('Telnet ping connection established'),
      onDisconnect: () {
        _logDebug('Telnet ping connection closed');
        timeoutTimer?.cancel();
        if (!completer.isCompleted) {
          final output = outputBuffer.toString();
          final result = _analyzePingResult(output);
          completer.complete(result);
        }
        subscription?.cancel();
      },
      onError: (error) {
        _logDebug('Telnet ping error: $error');
        timeoutTimer?.cancel();
        if (!completer.isCompleted) {
          completer.completeError(ServerFailure("Ping error: $error"));
        }
      },
    );

    try {
      subscription = (await client.connect())?.listen((data) {
        final receivedText = data.text;
        outputBuffer.write(receivedText);
        _logDebug("Ping Received: ${receivedText.replaceAll('\r\n', ' ')}");

        // Check for ping results in every message
        if (receivedText.contains('!!!!!') ||
            receivedText.contains('Success rate is 100') ||
            receivedText.contains('Success rate is 80')) {
          if (!completer.isCompleted) {
            timeoutTimer?.cancel();
            completer.complete('Success! Gateway is reachable.');
            client?.disconnect();
            return;
          }
        } else if (receivedText.contains('.....') ||
            receivedText.contains('Success rate is 0')) {
          if (!completer.isCompleted) {
            timeoutTimer?.cancel();
            completer.complete('Timeout. Gateway is not reachable.');
            client?.disconnect();
            return;
          }
        }

        final trimmedText = receivedText.trim();
        switch (state) {
          case 'login':
            if (trimmedText.toLowerCase().contains('username')) {
              client?.send('${credentials.username}\n');
            } else if (trimmedText.toLowerCase().contains('password')) {
              client?.send('${credentials.password}\n');
            } else if (trimmedText.endsWith('>')) {
              state = 'enable';
              client?.send('enable\n');
            } else if (trimmedText.endsWith('#')) {
              state = 'executing';
              if (!commandSent) {
                client?.send('ping $ipAddress repeat 5\n');
                commandSent = true;
              }
            }
            break;
          case 'enable':
            if (trimmedText.toLowerCase().contains('password')) {
              client?.send('${credentials.enablePassword ?? ''}\n');
            } else if (trimmedText.endsWith('#')) {
              state = 'executing';
              if (!commandSent) {
                client?.send('ping $ipAddress repeat 5\n');
                commandSent = true;
              }
            }
            break;
        }
      });
    } catch (e) {
      _logDebug('Error in Telnet ping: $e');
      timeoutTimer.cancel();
      if (!completer.isCompleted) {
        completer.completeError(ServerFailure("Ping connection failed: $e"));
      }
    }

    return completer.future;
  }

  Future<String> fetchDetailedInterfaces(DeviceCredentials credentials) async {
    try {
      final result = await _executeTelnetCommands(credentials, ['show running-config']);
      _logDebug('Telnet detailed config fetched');
      return result;
    } catch (e) {
      _logDebug('Error fetching Telnet detailed config: $e');
      rethrow;
    }
  }

  String _analyzePingResult(String output) {
    _logDebug('Analyzing ping result');
    if (output.contains('!!!!!') ||
        output.contains('Success rate is 100') ||
        output.contains('Success rate is 80')) {
      return 'Success! Gateway is reachable.';
    } else if (output.contains('.....') ||
        output.contains('Success rate is 0')) {
      return 'Timeout. Gateway is not reachable.';
    } else if (output.toLowerCase().contains('unknown host')) {
      return 'Error: Unknown host.';
    } else if (output.toLowerCase().contains('network unreachable')) {
      return 'Error: Network unreachable.';
    }

    return 'Ping failed. Check the IP or connection.';
  }

  Future<String> fetchInterfaces(DeviceCredentials credentials) async {
    try {
      final result = await _executeTelnetCommands(
          credentials, ['show ip interface brief']);
      _logDebug('Telnet interfaces fetched');
      return result;
    } catch (e) {
      _logDebug('Error fetching Telnet interfaces: $e');
      rethrow;
    }
  }

  Future<String> getRoutingTable(DeviceCredentials credentials) async {
    try {
      final result = await _executeTelnetCommands(credentials, ['show ip route']);
      _logDebug('Telnet routing table fetched');
      return result;
    } catch (e) {
      _logDebug('Error fetching Telnet routing table: $e');
      rethrow;
    }
  }

  Future<String> pingGateway(DeviceCredentials credentials, String ipAddress) async {
    return await _executeTelnetPing(credentials, ipAddress);
  }
  
  // New method to apply ECMP configuration via Telnet
  Future<String> applyEcmpConfig(DeviceCredentials credentials, String gateway1, String gateway2) async {
    _logDebug('Applying ECMP config via Telnet for gateways: $gateway1, $gateway2');
    try {
       final commands = [
        'configure terminal',
        'ip route 0.0.0.0 0.0.0.0 $gateway1',
        'ip route 0.0.0.0 0.0.0.0 $gateway2',
        'end'
      ];
      // We don't need 'terminal length 0' here, as _executeTelnetCommands adds it.
      // We pass the commands directly.
      final result = await _executeTelnetCommands(credentials, commands.sublist(1));
       _logDebug('ECMP config commands sent via Telnet');

      if (result.toLowerCase().contains('invalid input') || result.toLowerCase().contains('error')) {
          _logDebug('Error applying ECMP config via Telnet: $result');
          return 'Failed to apply ECMP configuration. Router response: ${result.split('\n').lastWhere((line) => line.contains('%') || line.contains('^'), orElse: () => 'Unknown error')}';
      }

      return 'ECMP configuration applied successfully.';
    } catch (e) {
       _logDebug('Error applying ECMP config via Telnet: $e');
       return 'An error occurred while applying ECMP configuration: ${e.toString()}';
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\data\repositories\device_repository_impl.dart ---

// lib/data/repositories/device_repository_impl.dart
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/data/datasources/remote_datasource.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';

class DeviceRepositoryImpl implements DeviceRepository {
  final RemoteDataSource remoteDataSource;

  DeviceRepositoryImpl({required this.remoteDataSource});

  @override
  Future<void> checkCredentials(DeviceCredentials credentials) async {
    // For SSH and Telnet, verifying credentials by fetching interfaces is a reliable check.
    if (credentials.type == ConnectionType.ssh ||
        credentials.type == ConnectionType.telnet) {
      try {
        await remoteDataSource.fetchInterfaces(credentials);
      } on ServerFailure catch (e) {
        throw ServerFailure(e.message);
      } catch (e) {
        throw ServerFailure(e.toString());
      }
    } else if (credentials.type == ConnectionType.restApi) {
      return await remoteDataSource.checkRestApiCredentials(credentials);
    }
  }

  @override
  Future<List<RouterInterface>> getInterfaces(
      DeviceCredentials credentials) async {
    try {
      return await remoteDataSource.fetchInterfaces(credentials);
    } on ServerFailure catch (e) {
      throw ServerFailure(e.message);
    } catch (e) {
      throw ServerFailure(e.toString());
    }
  }

  @override
  Future<String> getRoutingTable(DeviceCredentials credentials) async {
    try {
      return await remoteDataSource.getRoutingTable(credentials);
    } on ServerFailure catch (e) {
      return e.message;
    } catch (e) {
      return e.toString();
    }
  }

  @override
  Future<String> pingGateway(
      {required DeviceCredentials credentials,
      required String ipAddress}) async {
    try {
      return await remoteDataSource.pingGateway(credentials, ipAddress);
    } on ServerFailure catch (e) {
      return e.message;
    } catch (e) {
      return e.toString();
    }
  }

  // Implementation for the new ECMP method
  @override
  Future<String> applyEcmpConfig(
      {required DeviceCredentials credentials,
      required String gateway1,
      required String gateway2}) async {
    try {
      return await remoteDataSource.applyEcmpConfig(credentials, gateway1, gateway2);
    } on ServerFailure catch (e) {
      return e.message;
    } catch (e) {
      return e.toString();
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\entities\device_credentials.dart ---

// lib/domain/entities/device_credentials.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';

class DeviceCredentials extends Equatable {
  final String ip;
  final String username;
  final String password;
  final String? enablePassword;
  final ConnectionType type;
  final Duration connectionTimeout;
  final Duration commandTimeout;

  const DeviceCredentials({
    required this.ip,
    required this.username,
    required this.password,
    this.enablePassword,
    required this.type,
    this.connectionTimeout = const Duration(seconds: 10),
    this.commandTimeout = const Duration(seconds: 20),
  });

  // Data validation
  bool get isValid {
    if (ip.trim().isEmpty || username.trim().isEmpty || password.trim().isEmpty) {
      return false;
    }
    
    // IP format check
    final ipRegex = RegExp(r'^(\d{1,3}\.){3}\d{1,3}$');
    if (!ipRegex.hasMatch(ip.trim())) {
      return false;
    }
    
    // IP range check
    final parts = ip.trim().split('.');
    for (final part in parts) {
      final num = int.tryParse(part);
      if (num == null || num < 0 || num > 255) {
        return false;
      }
    }
    
    return true;
  }

  String? get validationError {
    if (ip.trim().isEmpty) return 'IP address cannot be empty';
    if (username.trim().isEmpty) return 'Username cannot be empty';
    if (password.trim().isEmpty) return 'Password cannot be empty';
    
    final ipRegex = RegExp(r'^(\d{1,3}\.){3}\d{1,3}$');
    if (!ipRegex.hasMatch(ip.trim())) {
      return 'Invalid IP address format';
    }
    
    final parts = ip.trim().split('.');
    for (final part in parts) {
      final num = int.tryParse(part);
      if (num == null || num < 0 || num > 255) {
        return 'IP address octets must be between 0-255';
      }
    }
    
    return null;
  }

  DeviceCredentials copyWith({
    String? ip,
    String? username,
    String? password,
    String? enablePassword,
    ConnectionType? type,
    Duration? connectionTimeout,
    Duration? commandTimeout,
  }) {
    return DeviceCredentials(
      ip: ip ?? this.ip,
      username: username ?? this.username,
      password: password ?? this.password,
      enablePassword: enablePassword ?? this.enablePassword,
      type: type ?? this.type,
      connectionTimeout: connectionTimeout ?? this.connectionTimeout,
      commandTimeout: commandTimeout ?? this.commandTimeout,
    );
  }

  @override
  List<Object?> get props => [
        ip,
        username,
        password,
        enablePassword,
        type,
        connectionTimeout,
        commandTimeout,
      ];
      
  @override
  String toString() {
    return 'DeviceCredentials(ip: $ip, username: $username, type: $type)';
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\entities\router_interface.dart ---

// domain/entities/router_interface.dart
import 'package:equatable/equatable.dart';

class RouterInterface extends Equatable {
  final String name;
  final String ipAddress;
  final String status;

  const RouterInterface({
    required this.name,
    required this.ipAddress,
    required this.status,
  });

  @override
  List<Object?> get props => [name, ipAddress, status];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\repositories\device_repository.dart ---

// lib/domain/repositories/device_repository.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';

abstract class DeviceRepository {
  Future<void> checkCredentials(DeviceCredentials credentials);
  Future<List<RouterInterface>> getInterfaces(DeviceCredentials credentials);
  Future<String> getRoutingTable(DeviceCredentials credentials);
  Future<String> pingGateway({
    required DeviceCredentials credentials,
    required String ipAddress,
  });
  // New method to apply ECMP configuration
  Future<String> applyEcmpConfig({
    required DeviceCredentials credentials,
    required String gateway1,
    required String gateway2,
  });
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\apply_ecmp_config.dart ---

// lib/domain/usecases/apply_ecmp_config.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class ApplyEcmpConfig {
  final DeviceRepository repository;

  ApplyEcmpConfig(this.repository);

  Future<String> call({
    required DeviceCredentials credentials,
    required String gateway1,
    required String gateway2,
  }) async {
    return await repository.applyEcmpConfig(
      credentials: credentials,
      gateway1: gateway1,
      gateway2: gateway2,
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\check_credentials.dart ---


// domain/usecases/check_credentials.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class CheckCredentials {
  final DeviceRepository repository;

  CheckCredentials(this.repository);

  Future<void> call(DeviceCredentials credentials) async {
    return await repository.checkCredentials(credentials);
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\get_interfaces.dart ---

// domain/usecases/get_interfaces.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class GetInterfaces {
  final DeviceRepository repository;

  GetInterfaces(this.repository);

  Future<List<RouterInterface>> call(DeviceCredentials credentials) async {
    return await repository.getInterfaces(credentials);
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\get_routing_table.dart ---

// domain/usecases/get_routing_table.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class GetRoutingTable {
  final DeviceRepository repository;

  GetRoutingTable(this.repository);

  Future<String> call(DeviceCredentials credentials) async {
    return await repository.getRoutingTable(credentials);
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\domain\usecases\ping_gateway.dart ---

// lib/domain/usecases/ping_gateway.dart
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/repositories/device_repository.dart';

class PingGateway {
  final DeviceRepository repository;

  PingGateway(this.repository);

  // The call method requires credentials to perform the operation on the device.
  Future<String> call({
    required DeviceCredentials credentials,
    required String ipAddress,
  }) async {
    return await repository.pingGateway(
      credentials: credentials,
      ipAddress: ipAddress,
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\connection\connection_bloc.dart ---

// presentation/bloc/connection/connection_bloc.dart
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/usecases/check_credentials.dart';
import 'connection_event.dart';
import 'connection_state.dart';

class ConnectionBloc extends Bloc<ConnectionEvent, ConnectionState> {
  final CheckCredentials checkCredentials;

  ConnectionBloc({required this.checkCredentials}) : super(ConnectionInitial()) {
    on<CheckCredentialsRequested>(_onCheckCredentials);
  }

  Future<void> _onCheckCredentials(
    CheckCredentialsRequested event,
    Emitter<ConnectionState> emit,
  ) async {
    emit(ConnectionLoading());
    try {
      final credentials = DeviceCredentials(
        ip: event.ip,
        username: event.username,
        password: event.password,
        enablePassword: event.enablePassword,
        type: event.type,
      );
      await checkCredentials(credentials);

      // Pass the credentials object in the success state
      emit(ConnectionSuccess(credentials));
    } on ServerFailure catch (e) {
      emit(ConnectionFailure(e.message));
    } catch (e) {
      emit(ConnectionFailure("An unexpected error occurred: ${e.toString()}"));
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\connection\connection_event.dart ---

// presentation/bloc/connection/connection_event.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/presentation/screens/connection/connection_screen.dart';

abstract class ConnectionEvent extends Equatable {
  const ConnectionEvent();

  @override
  List<Object?> get props => [];
}

class CheckCredentialsRequested extends ConnectionEvent {
  final String ip;
  final String username;
  final String password;
  final String? enablePassword;
  final ConnectionType type;

  const CheckCredentialsRequested({
    required this.ip,
    required this.username,
    required this.password,
    this.enablePassword,
    required this.type,
  });

  @override
  List<Object?> get props => [ip, username, password, enablePassword, type];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\connection\connection_state.dart ---

// presentation/bloc/connection/connection_state.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';

abstract class ConnectionState extends Equatable {
  const ConnectionState();

  @override
  List<Object> get props => [];
}

class ConnectionInitial extends ConnectionState {}

class ConnectionLoading extends ConnectionState {}

// Now holds the credentials on success to pass them to the next screen
class ConnectionSuccess extends ConnectionState {
  final DeviceCredentials credentials;
  const ConnectionSuccess(this.credentials);

  @override
  List<Object> get props => [credentials];
}

class ConnectionFailure extends ConnectionState {
  final String error;

  const ConnectionFailure(this.error);

  @override
  List<Object> get props => [error];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\load_balancing\load_balancing_bloc.dart ---

// lib/presentation/bloc/load_balancing/load_balancing_bloc.dart
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/core/error/failure.dart';
import 'package:load_balance/domain/usecases/apply_ecmp_config.dart';
import 'package:load_balance/domain/usecases/get_interfaces.dart';
import 'package:load_balance/domain/usecases/get_routing_table.dart';
import 'package:load_balance/domain/usecases/ping_gateway.dart';
import 'load_balancing_event.dart';
import 'load_balancing_state.dart';

class LoadBalancingBloc extends Bloc<LoadBalancingEvent, LoadBalancingState> {
  final GetInterfaces getInterfaces;
  final GetRoutingTable getRoutingTable;
  final PingGateway pingGateway;
  final ApplyEcmpConfig applyEcmpConfig; // New use case

  // Manage concurrent ping operations
  final Map<String, Timer> _pingTimers = {};

  LoadBalancingBloc({
    required this.getInterfaces,
    required this.getRoutingTable,
    required this.pingGateway,
    required this.applyEcmpConfig, // Injected dependency
  }) : super(const LoadBalancingState()) {
    on<ScreenStarted>(_onScreenStarted);
    on<FetchInterfacesRequested>(_onFetchInterfaces);
    on<FetchRoutingTableRequested>(_onFetchRoutingTable);
    on<PingGatewayRequested>(_onPingGateway);
    on<LoadBalancingTypeSelected>(_onLoadBalancingTypeSelected);
    on<ApplyEcmpConfig>(_onApplyEcmpConfig);
    on<ClearPingResult>(_onClearPingResult);
  }

  @override
  Future<void> close() {
    // Clean up timers
    for (final timer in _pingTimers.values) {
      timer.cancel();
    }
    _pingTimers.clear();
    return super.close();
  }

  void _logDebug(String message) {
    if (kDebugMode) {
      debugPrint('[LoadBalancingBloc] $message');
    }
  }

  void _onScreenStarted(ScreenStarted event, Emitter<LoadBalancingState> emit) {
    _logDebug('Screen started - IP: ${event.credentials.ip}');
    emit(state.copyWith(credentials: event.credentials));
    add(FetchInterfacesRequested());
  }

  void _onLoadBalancingTypeSelected(
    LoadBalancingTypeSelected event,
    Emitter<LoadBalancingState> emit,
  ) {
    _logDebug('Load Balancing type selected: ${event.type}');
    emit(state.copyWith(type: event.type));
  }

  void _onClearPingResult(
    ClearPingResult event,
    Emitter<LoadBalancingState> emit,
  ) {
    final newPingResults = Map<String, String>.from(state.pingResults);
    newPingResults.remove(event.ipAddress);
    emit(state.copyWith(pingResults: newPingResults));
  }

  Future<void> _onFetchInterfaces(
    FetchInterfacesRequested event,
    Emitter<LoadBalancingState> emit,
  ) async {
    if (state.credentials == null) {
      _logDebug('Error: Credentials not available');
      return;
    }

    _logDebug('Starting to fetch interfaces');
    emit(state.copyWith(interfacesStatus: DataStatus.loading));
    try {
      final interfaces = await getInterfaces(state.credentials!);
      _logDebug('${interfaces.length} interfaces received');
      emit(state.copyWith(
        interfaces: interfaces,
        interfacesStatus: DataStatus.success,
      ));
    } on ServerFailure catch (e) {
      _logDebug('Error fetching interfaces: ${e.message}');
      emit(state.copyWith(
        interfacesStatus: DataStatus.failure,
        error: e.message,
      ));
    } catch (e) {
      _logDebug('Unknown error fetching interfaces: $e');
      emit(state.copyWith(
        interfacesStatus: DataStatus.failure,
        error: 'An unknown error occurred while fetching interfaces.',
      ));
    }
  }

  Future<void> _onFetchRoutingTable(
    FetchRoutingTableRequested event,
    Emitter<LoadBalancingState> emit,
  ) async {
    if (state.credentials == null) {
      _logDebug('Error: Credentials not available');
      return;
    }

    _logDebug('Starting to fetch routing table');
    emit(state.copyWith(
      routingTableStatus: DataStatus.loading,
      clearRoutingTable: true,
    ));
    try {
      final table = await getRoutingTable(state.credentials!);
      _logDebug('Routing table received');
      emit(state.copyWith(
        routingTable: table,
        routingTableStatus: DataStatus.success,
      ));
    } on ServerFailure catch (e) {
      _logDebug('Error fetching routing table: ${e.message}');
      emit(state.copyWith(
        routingTable: 'Error: ${e.message}',
        routingTableStatus: DataStatus.failure,
      ));
    } catch (e) {
      _logDebug('Unknown error fetching routing table: $e');
      emit(state.copyWith(
        routingTable: 'An unknown error occurred while fetching routing table.',
        routingTableStatus: DataStatus.failure,
      ));
    }
  }

  Future<void> _onPingGateway(
    PingGatewayRequested event,
    Emitter<LoadBalancingState> emit,
  ) async {
    if (state.credentials == null) {
      _logDebug('Error: Credentials not available');
      return;
    }

    final ipAddress = event.ipAddress.trim();
    
    // IP Validation
    if (ipAddress.isEmpty) {
      _logDebug('Error: Empty IP for ping');
      final newPingResults = Map<String, String>.from(state.pingResults);
      newPingResults[''] = 'Error: IP address cannot be empty.';
      emit(state.copyWith(pingResults: newPingResults));
      return;
    }

    // Check if ping is already in progress
    if (state.pingingIp == ipAddress) {
      _logDebug('Ping for IP $ipAddress is already in progress');
      return;
    }

    // Cancel previous timer if it exists
    _pingTimers[ipAddress]?.cancel();
    _logDebug('Starting ping for IP: $ipAddress');
    emit(state.copyWith(
      pingStatus: DataStatus.loading,
      pingingIp: ipAddress,
    ));
    try {
      final result = await pingGateway(
        credentials: state.credentials!,
        ipAddress: ipAddress,
      );
      _logDebug('Ping result for $ipAddress: $result');
      
      _pingTimers[ipAddress]?.cancel();
      _pingTimers.remove(ipAddress);
      
      final newPingResults = Map<String, String>.from(state.pingResults);
      newPingResults[ipAddress] = result;
      
      emit(state.copyWith(
        pingResults: newPingResults,
        pingStatus: DataStatus.success,
        pingingIp: '',
      ));
    } catch (e) {
      _logDebug('Error during ping for $ipAddress: $e');
      _pingTimers[ipAddress]?.cancel();
      _pingTimers.remove(ipAddress);
      
      final newPingResults = Map<String, String>.from(state.pingResults);
      newPingResults[ipAddress] = 'Ping Error: ${e.toString()}';
      
      emit(state.copyWith(
        pingResults: newPingResults,
        pingStatus: DataStatus.failure,
        pingingIp: '',
      ));
    }
  }

  // Updated handler for applying ECMP configuration
  Future<void> _onApplyEcmpConfig(
    ApplyEcmpConfig event,
    Emitter<LoadBalancingState> emit,
  ) async {
    if (state.credentials == null) {
      _logDebug('Error: Credentials not available for applying config');
      return;
    }

    _logDebug('Starting to apply ECMP config');
    _logDebug('Gateway 1: ${event.gateway1}');
    _logDebug('Gateway 2: ${event.gateway2}');
    
    // Set loading state and clear any previous success/error messages
    emit(state.copyWith(status: DataStatus.loading, clearSuccessMessage: true));
    
    try {
      final result = await applyEcmpConfig(
        credentials: state.credentials!,
        gateway1: event.gateway1,
        gateway2: event.gateway2,
      );

      _logDebug('ECMP config apply result: $result');
      
      // Check result message for success or failure keywords
      if (result.toLowerCase().contains('fail') || result.toLowerCase().contains('error')) {
         emit(state.copyWith(
            status: DataStatus.failure,
            error: result,
          ));
      } else {
         emit(state.copyWith(
            status: DataStatus.success,
            successMessage: result,
          ));
      }
    } catch (e) {
      _logDebug('Error applying ECMP config: $e');
      emit(state.copyWith(
        status: DataStatus.failure,
        error: 'Failed to apply config: ${e.toString()}',
      ));
    }
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\load_balancing\load_balancing_event.dart ---

// lib/presentation/bloc/load_balancing/load_balancing_event.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart';

abstract class LoadBalancingEvent extends Equatable {
  const LoadBalancingEvent();
  @override
  List<Object?> get props => [];
}

class ScreenStarted extends LoadBalancingEvent {
  final DeviceCredentials credentials;
  const ScreenStarted(this.credentials);
  @override
  List<Object?> get props => [credentials];
}

class LoadBalancingTypeSelected extends LoadBalancingEvent {
  final LoadBalancingType type;
  const LoadBalancingTypeSelected(this.type);
  @override
  List<Object> get props => [type];
}

class FetchInterfacesRequested extends LoadBalancingEvent {}

class FetchRoutingTableRequested extends LoadBalancingEvent {}

class PingGatewayRequested extends LoadBalancingEvent {
  final String ipAddress;
  const PingGatewayRequested(this.ipAddress);
  @override
  List<Object?> get props => [ipAddress];
}

class ClearPingResult extends LoadBalancingEvent {
  final String ipAddress;
  const ClearPingResult(this.ipAddress);
  @override
  List<Object?> get props => [ipAddress];
}

class ApplyEcmpConfig extends LoadBalancingEvent {
  final String gateway1;
  final String gateway2;
  const ApplyEcmpConfig({required this.gateway1, required this.gateway2});
  @override
  List<Object> get props => [gateway1, gateway2];
}

class ApplyPbrConfig extends LoadBalancingEvent {
  final String sourceNetwork;
  final String gateway;
  const ApplyPbrConfig({required this.sourceNetwork, required this.gateway});
  @override
  List<Object> get props => [sourceNetwork, gateway];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\bloc\load_balancing\load_balancing_state.dart ---

// lib/presentation/bloc/load_balancing/load_balancing_state.dart
import 'package:equatable/equatable.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/domain/entities/router_interface.dart';

enum LoadBalancingType { ecmp, pbr }
enum DataStatus { initial, loading, success, failure }

class LoadBalancingState extends Equatable {
  // Holds the credentials to be used for each request
  final DeviceCredentials? credentials; 
  final LoadBalancingType type;
  // General status for operations like applying configs
  final DataStatus status; 
  final String error;
  // Specific message for successful operations
  final String? successMessage; 

  final List<RouterInterface> interfaces;
  final DataStatus interfacesStatus;

  final String? routingTable;
  final DataStatus routingTableStatus;

  final Map<String, String> pingResults;
  final DataStatus pingStatus;
  final String? pingingIp;

  const LoadBalancingState({
    this.credentials,
    this.type = LoadBalancingType.ecmp,
    this.status = DataStatus.initial,
    this.error = '',
    this.successMessage,
    this.interfaces = const [],
    this.interfacesStatus = DataStatus.initial,
    this.routingTable,
    this.routingTableStatus = DataStatus.initial,
    this.pingResults = const {},
    this.pingStatus = DataStatus.initial,
    this.pingingIp,
  });

  LoadBalancingState copyWith({
    DeviceCredentials? credentials,
    LoadBalancingType? type,
    DataStatus? status,
    String? error,
    String? successMessage,
    bool clearSuccessMessage = false,
    List<RouterInterface>? interfaces,
    DataStatus? interfacesStatus,
    String? routingTable,
    DataStatus? routingTableStatus,
    Map<String, String>? pingResults,
    DataStatus? pingStatus,
    String? pingingIp,
    bool clearRoutingTable = false,
  }) {
    return LoadBalancingState(
      credentials: credentials ?? this.credentials,
      type: type ?? this.type,
      status: status ?? this.status,
      // Clear error on new status, unless it's a failure status
      error: (status != null && status != DataStatus.failure) ? '' : error ?? this.error,
      // Handle clearing or setting the success message
      successMessage: clearSuccessMessage ? null : successMessage ?? this.successMessage,
      interfaces: interfaces ?? this.interfaces,
      interfacesStatus: interfacesStatus ?? this.interfacesStatus,
      routingTable: clearRoutingTable ? null : routingTable ?? this.routingTable,
      routingTableStatus: routingTableStatus ?? this.routingTableStatus,
      pingResults: pingResults ?? this.pingResults,
      pingStatus: pingStatus ?? this.pingStatus,
      pingingIp: pingingIp ?? this.pingingIp,
    );
  }

  @override
  List<Object?> get props => [
        credentials, type, status, error, successMessage, interfaces, interfacesStatus,
        routingTable, routingTableStatus, pingResults, pingStatus, pingingIp
      ];
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\connection\connection_screen.dart ---

// presentation/screens/connection/connection_screen.dart
import 'package:flutter/material.dart' hide ConnectionState;
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:go_router/go_router.dart';
import 'package:load_balance/presentation/bloc/connection/connection_bloc.dart';
import 'package:load_balance/presentation/bloc/connection/connection_event.dart';
import 'package:load_balance/presentation/bloc/connection/connection_state.dart';

enum ConnectionType { ssh, telnet, restApi }

class ConnectionScreen extends StatefulWidget {
  const ConnectionScreen({super.key});

  @override
  State<ConnectionScreen> createState() => _ConnectionScreenState();
}

class _ConnectionScreenState extends State<ConnectionScreen> {
  final _formKey = GlobalKey<FormState>();
  final _ipController = TextEditingController();
  final _usernameController = TextEditingController();
  final _passwordController = TextEditingController();
  final _enablePasswordController = TextEditingController();
  bool _isPasswordVisible = false;
  bool _isEnablePasswordVisible = false;

  ConnectionType _selectedType = ConnectionType.ssh;

  @override
  void dispose() {
    _ipController.dispose();
    _usernameController.dispose();
    _passwordController.dispose();
    _enablePasswordController.dispose();
    super.dispose();
  }

  void _checkCredentials() {
    if (_formKey.currentState!.validate()) {
      context.read<ConnectionBloc>().add(
            CheckCredentialsRequested(
              ip: _ipController.text,
              username: _usernameController.text,
              password: _passwordController.text,
              enablePassword: _enablePasswordController.text,
              type: _selectedType,
            ),
          );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Router Connection'),
      ),
      body: BlocListener<ConnectionBloc, ConnectionState>(
        listener: (context, state) {
          if (state is ConnectionSuccess) {
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(
                const SnackBar(
                  content: Text('Connection Successful!'),
                  backgroundColor: Colors.green,
                ),
              );
            // Navigate and pass credentials to the next screen
            context.go('/config', extra: state.credentials);
          } else if (state is ConnectionFailure) {
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(
                SnackBar(
                  content: Text('Error: ${state.error}'),
                  backgroundColor: Colors.red,
                ),
              );
          }
        },
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24.0),
            child: Form(
              key: _formKey,
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(
                    'Enter Router Credentials',
                    style: Theme.of(context).textTheme.headlineSmall,
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 32),
                  TextFormField(
                    controller: _ipController,
                    decoration: const InputDecoration(
                      labelText: 'IP Address',
                      prefixIcon: Icon(Icons.router),
                    ),
                    keyboardType: TextInputType.number,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please enter an IP address';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _usernameController,
                    decoration: const InputDecoration(
                      labelText: 'Username',
                      prefixIcon: Icon(Icons.person),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please enter a username';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: _passwordController,
                    obscureText: !_isPasswordVisible,
                    decoration: InputDecoration(
                      labelText: 'Password',
                      prefixIcon: const Icon(Icons.lock_outline),
                      suffixIcon: IconButton(
                        icon: Icon(_isPasswordVisible
                            ? Icons.visibility_off
                            : Icons.visibility),
                        onPressed: () => setState(
                            () => _isPasswordVisible = !_isPasswordVisible),
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return 'Please enter a password';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  Visibility(
                    visible: _selectedType != ConnectionType.restApi,
                    child: TextFormField(
                      controller: _enablePasswordController,
                      obscureText: !_isEnablePasswordVisible,
                      decoration: InputDecoration(
                        labelText: 'Enable Password (optional)',
                        prefixIcon: const Icon(Icons.lock),
                        suffixIcon: IconButton(
                          icon: Icon(_isEnablePasswordVisible
                              ? Icons.visibility_off
                              : Icons.visibility),
                          onPressed: () => setState(() =>
                              _isEnablePasswordVisible =
                                  !_isEnablePasswordVisible),
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 24),
                  SegmentedButton<ConnectionType>(
                    segments: const <ButtonSegment<ConnectionType>>[
                      ButtonSegment<ConnectionType>(
                          value: ConnectionType.ssh,
                          label: Text('SSHv2'),
                          icon: Icon(Icons.security)),
                      ButtonSegment<ConnectionType>(
                          value: ConnectionType.telnet,
                          label: Text('Telnet'),
                          icon: Icon(Icons.lan)),
                      ButtonSegment<ConnectionType>(
                          value: ConnectionType.restApi,
                          label: Text('REST API'),
                          icon: Icon(Icons.http)),
                    ],
                    selected: {_selectedType},
                    onSelectionChanged: (Set<ConnectionType> newSelection) {
                      setState(() {
                        _selectedType = newSelection.first;
                      });
                    },
                  ),
                  const SizedBox(height: 32),
                  BlocBuilder<ConnectionBloc, ConnectionState>(
                    builder: (context, state) {
                      if (state is ConnectionLoading) {
                        return const Center(child: CircularProgressIndicator());
                      }
                      return ElevatedButton.icon(
                        icon: const Icon(Icons.login),
                        label: const Text('Check Credentials'),
                        onPressed: _checkCredentials,
                        style: ElevatedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 16),
                          textStyle: const TextStyle(fontSize: 16),
                        ),
                      );
                    },
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\load_balancing\load_balancing_screen.dart ---

// lib/presentation/screens/load_balancing/load_balancing_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/domain/entities/device_credentials.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_event.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart';
import 'package:load_balance/presentation/screens/load_balancing/widgets/ecmp_form.dart';
import 'package:load_balance/presentation/screens/load_balancing/widgets/pbr_form.dart';

class LoadBalancingScreen extends StatefulWidget {
  final DeviceCredentials credentials;
  const LoadBalancingScreen({super.key, required this.credentials});

  @override
  State<LoadBalancingScreen> createState() => _LoadBalancingScreenState();
}

class _LoadBalancingScreenState extends State<LoadBalancingScreen> {
  @override
  void initState() {
    super.initState();
    // Start the process by passing credentials to the BLoC.
    context.read<LoadBalancingBloc>().add(ScreenStarted(widget.credentials));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Load Balancing Configuration'),
      ),
      body: BlocListener<LoadBalancingBloc, LoadBalancingState>(
        // Listen for general status changes (e.g., after applying config)
        listenWhen: (previous, current) => previous.status != current.status,
        listener: (context, state) {
          if (state.status == DataStatus.success && state.successMessage != null) {
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(
                SnackBar(
                  content: Text(state.successMessage!),
                  backgroundColor: Colors.green,
                ),
              );
          } else if (state.status == DataStatus.failure && state.error.isNotEmpty) {
            ScaffoldMessenger.of(context)
              ..hideCurrentSnackBar()
              ..showSnackBar(
                SnackBar(
                  content: Text('Error: ${state.error}'),
                  backgroundColor: Colors.red,
                ),
              );
          }
        },
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Text(
                'Select Load Balancing Method',
                style: Theme.of(context).textTheme.titleLarge,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),
              BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
                builder: (context, state) {
                  return SegmentedButton<LoadBalancingType>(
                    segments: const <ButtonSegment<LoadBalancingType>>[
                      ButtonSegment<LoadBalancingType>(
                        value: LoadBalancingType.ecmp,
                        label: Text('ECMP'),
                        icon: Icon(Icons.alt_route),
                      ),
                      ButtonSegment<LoadBalancingType>(
                        value: LoadBalancingType.pbr,
                        label: Text('PBR'),
                        icon: Icon(Icons.rule),
                      ),
                    ],
                    selected: {state.type},
                    onSelectionChanged: (Set<LoadBalancingType> newSelection) {
                      context
                          .read<LoadBalancingBloc>()
                          .add(LoadBalancingTypeSelected(newSelection.first));
                    },
                  );
                },
              ),
              const SizedBox(height: 24),
              const _RouterInfoSection(), // Widget for smart features
              const SizedBox(height: 24),
              BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
                builder: (context, state) {
                  if (state.type == LoadBalancingType.ecmp) {
                    return const EcmpForm();
                  } else {
                    return const PbrForm();
                  }
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// A private widget to display router info (Interfaces and Routing Table)
class _RouterInfoSection extends StatelessWidget {
  const _RouterInfoSection();

  @override
  Widget build(BuildContext context) {
    final state = context.watch<LoadBalancingBloc>().state;
    return Card(
      clipBehavior: Clip.antiAlias,
      child: ExpansionTile(
        initiallyExpanded: true,
        title: const Text('Router Information'),
        subtitle: const Text('View interfaces and routing table'),
        children: [
          _buildInterfacesInfo(context, state),
          const Divider(height: 1),
          _buildRoutingTableInfo(context, state),
        ],
      ),
    );
  }

  Widget _buildInterfacesInfo(
      BuildContext context, LoadBalancingState state) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Text('Device Interfaces',
                style: Theme.of(context).textTheme.titleMedium),
          ),
          const SizedBox(height: 8),
          if (state.interfacesStatus == DataStatus.loading)
            const Center(child: CircularProgressIndicator())
          else if (state.interfacesStatus == DataStatus.failure)
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Text('Error fetching interfaces: ${state.error}',
                  style: const TextStyle(color: Colors.red)),
            )
          else if (state.interfaces.isEmpty)
            const Padding(
              padding: EdgeInsets.symmetric(horizontal: 16.0),
              child: Text('No active interfaces found or connection failed.'),
            )
          else
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: DataTable(
                columns: const [
                  DataColumn(label: Text('Interface')),
                  DataColumn(label: Text('IP Address')),
                  DataColumn(label: Text('Status')),
                ],
                rows: state.interfaces
                    .map((iface) => DataRow(
                          cells: [
                            DataCell(Text(iface.name)),
                            DataCell(Text(iface.ipAddress)),
                            DataCell(Text(
                              iface.status,
                              style: TextStyle(
                                  color: iface.status == 'up'
                                      ? Colors.green
                                      : Colors.orange),
                            )),
                          ],
                        ))
                    .toList(),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildRoutingTableInfo(
      BuildContext context, LoadBalancingState state) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text('IP Routing Table',
                  style: Theme.of(context).textTheme.titleMedium),
              if (state.routingTableStatus != DataStatus.loading)
                IconButton(
                  icon: const Icon(Icons.refresh),
                  tooltip: 'Refresh Routing Table',
                  onPressed: state.credentials == null
                      ? null
                      : () {
                          context
                              .read<LoadBalancingBloc>()
                              .add(FetchRoutingTableRequested());
                        },
                )
              else
                const SizedBox(
                    height: 24,
                    width: 24,
                    child: CircularProgressIndicator(strokeWidth: 2)),
            ],
          ),
          const SizedBox(height: 8),
          if (state.routingTableStatus == DataStatus.loading &&
              state.routingTable == null)
            const Center(child: Text('Fetching...'))
          else if (state.routingTable != null)
            Container(
              padding: const EdgeInsets.all(8),
              color: Colors.black.withAlpha((255 * 0.3).round()),
              width: double.infinity,
              child: SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: Text(
                  state.routingTable!,
                  style: const TextStyle(fontFamily: 'monospace', fontSize: 12),
                ),
              ),
            )
          else
            const Text('Press refresh to view the routing table.'),
        ],
      ),
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\load_balancing\widgets\ecmp_form.dart ---

// lib/presentation/screens/load_balancing/widgets/ecmp_form.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_bloc.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_event.dart';
import 'package:load_balance/presentation/bloc/load_balancing/load_balancing_state.dart';

class EcmpForm extends StatefulWidget {
  const EcmpForm({super.key});

  @override
  State<EcmpForm> createState() => _EcmpFormState();
}

class _EcmpFormState extends State<EcmpForm> {
  final _formKey = GlobalKey<FormState>();
  final _gateway1Controller = TextEditingController();
  final _gateway2Controller = TextEditingController();
  // IP validation regex
  static final _ipRegex = RegExp(r'^(\d{1,3}\.){3}\d{1,3}$');

  @override
  void dispose() {
    _gateway1Controller.dispose();
    _gateway2Controller.dispose();
    super.dispose();
  }

  bool _isValidIp(String ip) {
    if (!_ipRegex.hasMatch(ip)) return false;

    final parts = ip.split('.');
    for (final part in parts) {
      final num = int.tryParse(part);
      if (num == null || num < 0 || num > 255) return false;
    }
    return true;
  }

  void _applyEcmpConfig() {
    if (_formKey.currentState!.validate()) {
      context.read<LoadBalancingBloc>().add(
            ApplyEcmpConfig(
              gateway1: _gateway1Controller.text.trim(),
              gateway2: _gateway2Controller.text.trim(),
            ),
          );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      clipBehavior: Clip.antiAlias,
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Text(
                'ECMP Settings',
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              Text(
                'Enter the IP addresses of your internet gateways. Traffic will be distributed equally between them.',
                style: Theme.of(context).textTheme.bodyMedium,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),
              _GatewayInputField(
                controller: _gateway1Controller,
                label: 'Gateway 1',
                hint: 'e.g., 192.168.1.1',
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Gateway 1 IP address is required';
                  }
                  if (!_isValidIp(value.trim())) {
                    return 'Invalid IP address format';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              _GatewayInputField(
                controller: _gateway2Controller,
                label: 'Gateway 2',
                hint: 'e.g., 192.168.2.1',
                validator: (value) {
                  if (value == null || value.trim().isEmpty) {
                    return 'Gateway 2 IP address is required';
                  }
                  if (!_isValidIp(value.trim())) {
                    return 'Invalid IP address format';
                  }
                  if (value.trim() == _gateway1Controller.text.trim()) {
                    return 'Gateway 2 cannot be the same as Gateway 1';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 24),
              BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
                builder: (context, state) {
                  if (state.status == DataStatus.loading) {
                    return const Center(child: CircularProgressIndicator());
                  }
                  return ElevatedButton.icon(
                    onPressed: _applyEcmpConfig,
                    icon: const Icon(Icons.settings),
                    label: const Text('Apply Settings'),
                  );
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// Improved _GatewayInputField to prevent pinging with an empty IP
class _GatewayInputField extends StatelessWidget {
  final TextEditingController controller;
  final String label;
  final String hint;
  final String? Function(String?)? validator;
  const _GatewayInputField({
    required this.controller,
    required this.label,
    required this.hint,
    this.validator,
  });
  // IP validation regex
  static final _ipRegex = RegExp(r'^(\d{1,3}\.){3}\d{1,3}$');

  bool _isValidIp(String ip) {
    if (ip.trim().isEmpty) return false;
    if (!_ipRegex.hasMatch(ip.trim())) return false;

    final parts = ip.trim().split('.');
    for (final part in parts) {
      final num = int.tryParse(part);
      if (num == null || num < 0 || num > 255) return false;
    }
    return true;
  }

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<LoadBalancingBloc, LoadBalancingState>(
      builder: (context, state) {
        final ipAddress = controller.text.trim();
        final pingResult = state.pingResults[ipAddress];
        final isPinging = state.pingingIp == ipAddress;
        final canPing = ipAddress.isNotEmpty && _isValidIp(ipAddress) && !isPinging;

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            TextFormField(
              controller: controller,
              validator: validator,
              decoration: InputDecoration(
                labelText: label,
                hintText: hint,
                border: const OutlineInputBorder(),
                suffixIcon: isPinging
                    ? const Padding(
                        padding: EdgeInsets.all(12.0),
                        child: SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        ),
                      )
                    : IconButton(
                        icon: const Icon(Icons.network_ping),
                        tooltip: canPing ? 'Ping Gateway' : 'Enter a valid IP to ping',
                        onPressed: canPing
                            ? () {
                                context
                                    .read<LoadBalancingBloc>()
                                    .add(PingGatewayRequested(controller.text.trim()));
                              }
                            : null,
                      ),
              ),
              onChanged: (value) {
                // Trigger a rebuild to update the ping button's enabled state
                if (context.mounted) {
                  (context as Element).markNeedsBuild();
                }
              },
            ),
            if (pingResult != null) ...[
              const SizedBox(height: 8),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                decoration: BoxDecoration(
                  color: pingResult.toLowerCase().contains('success')
                      ? Colors.green.withAlpha((.1 * 255).round())
                      : Colors.orange.withAlpha((.1 * 255).round()),
                  border: Border.all(
                    color: pingResult.toLowerCase().contains('success')
                        ? Colors.green
                        : Colors.orange,
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(
                      pingResult.toLowerCase().contains('success')
                          ? Icons.check_circle
                          : Icons.warning,
                      size: 16,
                      color: pingResult.toLowerCase().contains('success')
                          ? Colors.green
                          : Colors.orange,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        pingResult,
                        style: TextStyle(
                          fontSize: 12,
                          color: pingResult.toLowerCase().contains('success')
                              ? Colors.green.shade700
                              : Colors.orange.shade700,
                        ),
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.close, size: 16),
                      onPressed: () {
                        context
                            .read<LoadBalancingBloc>()
                            .add(ClearPingResult(ipAddress));
                      },
                      tooltip: 'Clear Result',
                    ),
                  ],
                ),
              ),
            ],
          ],
        );
      },
    );
  }
}

--- FILE: C:\Users\Moein\Documents\Codes\Load_Balance\load_balance\lib\presentation\screens\load_balancing\widgets\pbr_form.dart ---

// presentation/screens/load_balancing/widgets/pbr_form.dart
import 'package:flutter/material.dart';

class PbrForm extends StatefulWidget {
  const PbrForm({super.key});
  @override
  State<PbrForm> createState() => _PbrFormState();
}

class _PbrFormState extends State<PbrForm> {
  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              'PBR Configuration',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 8),
            const Text(
                'Define policies to route specific traffic through different gateways. (Coming Soon)'),
            const SizedBox(height: 24),
            // UI elements for PBR will be added here
            const Center(
              child: Text(
                'PBR configuration UI is under development.',
                style: TextStyle(fontStyle: FontStyle.italic),
              ),
            ),
            const SizedBox(height: 32),
            ElevatedButton.icon(
              onPressed: null, // Disabled for now
              icon: const Icon(Icons.check_circle_outline),
              label: const Text('Apply Configuration'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 16),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
